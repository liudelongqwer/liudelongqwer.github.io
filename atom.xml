<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拒绝再玩</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-07T07:49:10.517Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>duoyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>控制器-Deployment</title>
    <link href="http://yoursite.com/2020/04/02/%E6%8E%A7%E5%88%B6%E5%99%A8-Deployment/"/>
    <id>http://yoursite.com/2020/04/02/%E6%8E%A7%E5%88%B6%E5%99%A8-Deployment/</id>
    <published>2020-04-02T02:57:28.000Z</published>
    <updated>2020-04-07T07:49:10.517Z</updated>
    
    <content type="html"><![CDATA[<p>控制器-Deployment</p> <a id="more"></a><h1 id="一、Deployment-概述"><a href="#一、Deployment-概述" class="headerlink" title="一、Deployment 概述"></a>一、Deployment 概述</h1><table><thead><tr><th>英文</th><th>英文简称</th><th>中文</th></tr></thead><tbody><tr><td>Pod</td><td>Pod</td><td>容器组</td></tr><tr><td>Controller</td><td>Controller</td><td>控制器</td></tr><tr><td>ReplicaSet</td><td>ReplicaSet</td><td>副本集</td></tr><tr><td>Deployment</td><td>Deployment</td><td>部署</td></tr></tbody></table><p>Deployment 是最常用的用于部署无状态服务的方式。Deployment 控制器使得您能够以声明的方式更新 Pod（容器组）和 ReplicaSet（副本集）。 </p><blockquote><p>声明式配置</p><p>声明的方式是相对于非声明方式而言的。例如，以滚动更新为例，假设有 3 个容器组，现需要将他们的容器镜像更新为新的版本。</p><ul><li>非声明的方式，需要手动逐步执行以下过程：<ul><li>使用 kubectl 创建一个新版本镜像的容器组</li><li>使用 kubectl 观察新建容器组的状态</li><li>新建容器组的状态就绪以后，使用 kubectl 删除一个旧的容器组</li><li>重复执行上述过程，直到所有容器组都已经替换为新版本镜像的容器组</li></ul></li><li>声明的方式，只需要执行：<ul><li>使用 kubectl 更新 Deployment 定义中 spec.template.spec.containers[].image 字段</li></ul></li></ul></blockquote><h1 id="二、创建-Deployment"><a href="#二、创建-Deployment" class="headerlink" title="二、创建 Deployment"></a>二、创建 Deployment</h1><p>下面的 yaml 文件定义了一个 Deployment，该 Deployment 将创建一个有 3 个 nginx Pod 副本的 ReplicaSet（副本集）： </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><strong>在这个例子中：</strong></p><ul><li>将创建一个名为 nginx-deployment 的 Deployment（部署），名称由 <code>.metadata.name</code> 字段指定</li><li>该 Deployment 将创建 3 个 Pod 副本，副本数量由 <code>.spec.replicas</code> 字段指定</li><li><code>.spec.selector</code> 字段指定了 Deployment 如何找到由它管理的 Pod。此案例中，我们使用了 Pod template 中定义的一个标签（app: nginx）。对于极少数的情况，这个字段也可以定义更加复杂的规则</li><li>.template 字段包含了如下字段：<ul><li><code>.template.metadata.labels</code> 字段，指定了 Pod 的标签（app: nginx）</li><li><code>.template.spec.containers[].image</code> 字段，表明该 Pod 运行一个容器 <code>nginx:1.7.9</code></li><li><code>.template.spec.containers[].name</code> 字段，表明该容器的名字是 <code>nginx</code></li></ul></li></ul><p><strong>注意：</strong></p><p>必须为 Deployment 中的 <code>.spec.selector</code> 和 <code>.template.metadata.labels</code> 定义一个合适的标签（这个例子中的标签是 app: nginx）。请不要使用与任何其他控制器（其他 Deployment / StatefulSet 等）相同的 <code>.spec.selector</code> 和 <code>.template.metadata.labels</code>。否则可能发生冲突。</p><p>1.执行命令以创建 Deployment， 可以为该命令增加 –record 选项， 这样可以回顾某一个 Deployment 版本变化的原因 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master 0402]# kubectl apply -f deploy.yaml --record </span><br><span class="line">deployment.apps&#x2F;nginx-deployment configured</span><br></pre></td></tr></table></figure><p>2.查看 Deployment 的创建情况 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master 0402]# kubectl get deployments</span><br><span class="line">NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">myapp              2&#x2F;2     2            2           2d1h</span><br><span class="line">nginx-deployment   2&#x2F;3     3            2           11m</span><br></pre></td></tr></table></figure><p><strong>字段含义</strong></p><table><thead><tr><th>字段名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>NAME</strong></td><td>Deployment name</td></tr><tr><td><strong>DESIRED</strong></td><td>Deployment 期望的 Pod 副本数，即 Deployment 中 <code>.spec.replicas</code> 字段指定的数值。该数值是“期望”值</td></tr><tr><td><strong>CURRENT</strong></td><td>当前有多少个 Pod 副本数在运行</td></tr><tr><td><strong>UP-TO-DATE</strong></td><td>Deployment 中，符合当前 Pod Template 定义的 Pod 数量</td></tr><tr><td><strong>AVAILABLE</strong></td><td>当前对用户可用的 Pod 副本数</td></tr><tr><td><strong>AGE</strong></td><td>Deployment 部署以来到现在的时长</td></tr></tbody></table><p>3.查看该 Deployment 创建的 ReplicaSet（rs），执行命令 <code>kubectl get rs</code>，输出结果如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master 0402]# kubectl get rs</span><br><span class="line">NAME                          DESIRED   CURRENT   READY   AGE</span><br><span class="line">myapp-57c9b8fc4               2         2         2       2d1h</span><br><span class="line">nginx-deployment-54f57cf6bf   3         3         2       26m</span><br></pre></td></tr></table></figure><p> 4.查看 Pod 的标签，执行命令 <code>kubectl get pods --show-labels</code>，输出结果如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master 0402]# kubectl get pods --show-labels </span><br><span class="line">NAME                                READY   STATUS             RESTARTS   AGE     LABELS</span><br><span class="line">init-demo                           1&#x2F;1     Running            0          42h     &lt;none&gt;</span><br><span class="line">lifecycle-demo                      1&#x2F;1     Running            0          4d20h   &lt;none&gt;</span><br><span class="line">myapp-57c9b8fc4-b4cqb               1&#x2F;1     Running            0          2d      app&#x3D;myapp,pod-template-hash&#x3D;57c9b8fc4</span><br><span class="line">myapp-57c9b8fc4-xtcwv               1&#x2F;1     Running            0          2d1h    app&#x3D;myapp,pod-template-hash&#x3D;57c9b8fc4</span><br><span class="line">nginx-deployment-54f57cf6bf-4kl6r   1&#x2F;1     Running            0          26m     app&#x3D;nginx,pod-template-hash&#x3D;54f57cf6bf</span><br><span class="line">nginx-deployment-54f57cf6bf-7zc2j   1&#x2F;1     Running            0          26m     app&#x3D;nginx,pod-template-hash&#x3D;54f57cf6bf</span><br><span class="line">nginx-deployment-54f57cf6bf-jnzkj   0&#x2F;1     ImagePullBackOff   0          26m     app&#x3D;nginx,pod-template-hash&#x3D;54f57cf6bf</span><br></pre></td></tr></table></figure><h1 id="三、更新-Deployment"><a href="#三、更新-Deployment" class="headerlink" title="三、更新 Deployment"></a>三、更新 Deployment</h1><h3 id="使用下述步骤更新您的-Deployment"><a href="#使用下述步骤更新您的-Deployment" class="headerlink" title="使用下述步骤更新您的 Deployment"></a><strong>使用下述步骤更新您的 Deployment</strong></h3><h3 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h3><ol><li>执行以下命令，将容器镜像从 nginx:1.7.9 更新到 nginx:1.9.1</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master 0402]# kubectl --record deployment.apps&#x2F;nginx-deployment set image deployment.v1.apps&#x2F;nginx-deployment nginx&#x3D;nginx:1.9.1</span><br><span class="line">deployment.apps&#x2F;nginx-deployment image updated</span><br><span class="line">deployment.apps&#x2F;nginx-deployment image updated</span><br></pre></td></tr></table></figure><h3 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h3><p>使用 <code>edit</code> 该 Deployment，并将 <code>.spec.template.spec.containers[0].image</code> 从 <code>nginx:1.7.9</code> 修改为 <code>nginx:1.9.1</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master 0402]# kubectl edit deployment nginx-deployment</span><br><span class="line">deployment.apps&#x2F;nginx-deployment edited</span><br></pre></td></tr></table></figure><ul><li>如果想要修改这些新的 Pod，只需要再次修改 Deployment 的 Pod template。</li><li>Deployment 将确保更新过程中，任意时刻只有一定数量的 Pod 被关闭。默认情况下，Deployment 确保至少 <code>.spec.replicas</code> 的 75% 的 Pod 保持可用（25% max unavailable）</li><li>Deployment 将确保更新过程中，任意时刻只有一定数量的 Pod 被创建。默认情况下，Deployment 确保最多 <code>.spec.replicas</code> 的 25% 的 Pod 被创建（25% max surge）</li></ul><p>Deployment Controller 先创建一个新 Pod，然后删除一个旧 Pod，然后再创建新的，如此循环，直到全部更新。Deployment Controller 不会 kill 旧的 Pod，除非足够数量的新 Pod 已经就绪，Deployment Controller 也不会创新新 Pod 直到足够数量的旧 Pod 已经被 kill。这个过程将确保更新过程中，任意时刻，最少 2 个 / 最多 4 个 Pod 可用。</p><h2 id="覆盖更新-Rollover-（更新过程中再更新）"><a href="#覆盖更新-Rollover-（更新过程中再更新）" class="headerlink" title="覆盖更新 Rollover （更新过程中再更新）"></a>覆盖更新 Rollover （更新过程中再更新）</h2><p>每创建一个 Deployment，Deployment Controller 都为其创建一个 ReplicaSet，并设定其副本数为期望的 Pod 数（ <code>.spec.replicas</code> 字段）。如果 Deployment 被更新，旧的 ReplicaSet 将被 Scale down，新建的 ReplicaSet 将被 Scale up；直到最后新旧两个 ReplicaSet，一个副本数为 <code>.spec.replias</code>，另一个副本数为 0。这个过程称为 rollout。</p><p>当 Deployment 的 rollout 正在进行中的时候，如果再次更新 Deployment 的信息，此时 Deployment 将再创建一个新的 ReplicaSet 并开始将其 scale up，将先前正在 scale up 的 ReplicaSet 也作为一个旧的 ReplicaSet，并开始将其 scale down。</p><p>例如：</p><ul><li>假设创建了一个 Deployment 有 5 个 nginx:1.7.9 的副本；</li><li>立刻更新该 Deployment 使得其 <code>.spec.replicas</code> 为 5，容器镜像为 <code>nginx:1.9.1</code>，而此时只有 3 个 nginx:1.7.9 的副本已创建；</li><li>此时，Deployment Controller 将立刻开始 kill 已经创建的 3 个 nginx:1.7.9 的 Pod，并开始创建 nginx:1.9.1 的 Pod。Deployment Controller 不会等到 5 个 nginx:1.7.9 的 Pod 都创建完之后在开始新的更新</li></ul><h1 id="四、回滚-Deployment"><a href="#四、回滚-Deployment" class="headerlink" title="四、回滚 Deployment"></a>四、回滚 Deployment</h1><h2 id="模拟更新错误"><a href="#模拟更新错误" class="headerlink" title="模拟更新错误"></a>模拟更新错误</h2><ul><li><p>假设您在更新 Deployment 的时候，犯了一个拼写错误，将 <code>nginx:1.9.1</code> 写成了 <code>nginx:1.91</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployment.v1.apps/nginx-deployment nginx=nginx:1.91 --record=<span class="literal">true</span></span><br><span class="line">deployment.apps/nginx-deployment image updated</span><br></pre></td></tr></table></figure></li><li><p>该更新将卡住，执行命令 <code>kubectl rollout status deployment.v1.apps/nginx-deployment</code> 检查其状态，输出结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Waiting for rollout to finish: 1 out of 3 new replicas have been updated...</span><br></pre></td></tr></table></figure></li></ul><h2 id="检查Deployment的更新历史"><a href="#检查Deployment的更新历史" class="headerlink" title="检查Deployment的更新历史"></a>检查Deployment的更新历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master 0402]# kubectl rollout history deployment nginx-deployment</span><br><span class="line">deployment.apps&#x2F;nginx-deployment </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">2         kubectl deployment.apps&#x2F;nginx-deployment set image deployment.v1.apps&#x2F;nginx-deployment nginx&#x3D;nginx:1.9.1 --record&#x3D;true</span><br><span class="line">3         kubectl deployment.apps&#x2F;nginx-deployment set image deployment.v1.apps&#x2F;nginx-deployment nginx&#x3D;nginx:1.9.1 --record&#x3D;true</span><br></pre></td></tr></table></figure><p>执行命令 <code>kubectl rollout history deployment.v1.apps/nginx-deployment --revision=2</code>，查看 revision（版本）的详细信息，输出结果如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master 0402]# kubectl rollout history deployment.v1.apps&#x2F;nginx-deployment --revision&#x3D;2</span><br><span class="line">deployment.apps&#x2F;nginx-deployment with revision #2</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:app&#x3D;nginx</span><br><span class="line">pod-template-hash&#x3D;56f8998dbc</span><br><span class="line">  Annotations:kubernetes.io&#x2F;change-cause:</span><br><span class="line">  kubectl deployment.apps&#x2F;nginx-deployment set image deployment.v1.apps&#x2F;nginx-deployment nginx&#x3D;nginx:1.9.1 --record&#x3D;true</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:nginx:1.9.1</span><br><span class="line">    Port:80&#x2F;TCP</span><br><span class="line">    Host Port:0&#x2F;TCP</span><br><span class="line">    Environment:&lt;none&gt;</span><br><span class="line">    Mounts:&lt;none&gt;</span><br><span class="line">  Volumes:&lt;none&gt;</span><br></pre></td></tr></table></figure><h2 id="回滚到前一个-revision（版本）"><a href="#回滚到前一个-revision（版本）" class="headerlink" title="回滚到前一个 revision（版本）"></a>回滚到前一个 revision（版本）</h2><p>下面的步骤可将 Deployment 从当前版本回滚到前一个版本（version 2）</p><p>执行命令 <code>kubectl rollout undo deployment.v1.apps/nginx-deployment</code> 将当前版本回滚到前一个版本，输出结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deployment.apps&#x2F;nginx-deployment</span><br></pre></td></tr></table></figure><p> 或者，也可以使用 <code>--to-revision</code> 选项回滚到前面的某一个指定版本，执行如下命令： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision=2</span><br></pre></td></tr></table></figure><ul><li>此时，Deployment 已经被回滚到前一个稳定版本。可以看到 Deployment Controller 为该 Deployment 产生了 DeploymentRollback event。</li><li>执行命令 <code>kubectl get deployment nginx-deployment</code>，检查该回滚是否成功，Deployment 是否按预期的运行。</li></ul><h1 id="五、伸缩-Deployment"><a href="#五、伸缩-Deployment" class="headerlink" title="五、伸缩 Deployment"></a>五、伸缩 Deployment</h1><h2 id="执行伸缩"><a href="#执行伸缩" class="headerlink" title="执行伸缩"></a>执行伸缩</h2><ul><li>执行命令 <code>kubectl scale deployment  nginx-deployment --replicas=5</code>，可以伸缩 Deployment，输出结果如下所示：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master 0402]<span class="comment"># kubectl scale deployment nginx-deployment --replicas=5</span></span><br><span class="line">deployment.apps/nginx-deployment scaled</span><br><span class="line"></span><br><span class="line">[root@k8s-master 0402]<span class="comment"># kubectl get deployment</span></span><br><span class="line">NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment   4/5     5            4           5h59m</span><br><span class="line"></span><br><span class="line">[root@k8s-master 0402]<span class="comment"># kubectl get pod</span></span><br><span class="line">NAME                                READY   STATUS             RESTARTS   AGE</span><br><span class="line">nginx-deployment-54f57cf6bf-4kl6r   1/1     Running            0          5h59m</span><br><span class="line">nginx-deployment-54f57cf6bf-7zc2j   1/1     Running            0          5h59m</span><br><span class="line">nginx-deployment-54f57cf6bf-lch2d   1/1     Running            0          35s</span><br><span class="line">nginx-deployment-54f57cf6bf-mzrzq   1/1     Running            0          35s</span><br><span class="line">nginx-deployment-54f57cf6bf-pmgj8   0/1     ImagePullBackOff   0          3h22m</span><br></pre></td></tr></table></figure><p> 如果集群启用了自动伸缩，执行以下命令，就可以基于 CPU 的利用率在一个最大和最小的区间自动伸缩您的 Deployment： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl autoscale deployment.v1.apps/nginx-deployment --min=10 --max=15 --cpu-percent=80</span><br></pre></td></tr></table></figure><h2 id="按比例伸缩"><a href="#按比例伸缩" class="headerlink" title="按比例伸缩"></a>按比例伸缩</h2><p>例如，假设已经运行了一个 10 副本数的 Deployment，其 maxSurge=3, maxUnavailable=2。</p><ul><li>执行命令 <code>kubectl scale deployment.v1.apps/nginx-deployment --replicas=15</code>，将 Deployment 的 replicas 调整到 15。此时，Deployment Controller 需要决定如何分配新增的 5 个 Pod 副本。根据“按比例伸缩”的原则：<ul><li>更大比例的新 Pod 数被分配到副本数最多的 ReplicaSet</li><li>更小比例的新 Pod 数被分配到副本数最少的 ReplicaSet</li><li>如果还有剩余的新 Pod 数未分配，则将被增加到副本数最多的 ReplicaSet</li><li>副本数为 0 的 ReplicaSet，scale up 之后，副本数仍然为 0</li></ul></li><li>在本例中，3 个新副本被添加到旧的 ReplicaSet，2个新副本被添加到新的 ReplicaSet。如果新的副本都达到就绪状态，滚动更新过程最终会将所有的副本数添加放到新 ReplicaSet。</li></ul><h1 id="六、暂停和继续-Deployment"><a href="#六、暂停和继续-Deployment" class="headerlink" title="六、暂停和继续 Deployment"></a>六、暂停和继续 Deployment</h1><p>可以先暂停 Deployment，然后再触发一个或多个更新，最后再继续（resume）该 Deployment。这种做法使得在暂停和继续中间对 Deployment 做多次更新，而无需触发不必要的滚动更新。 </p><p>执行命令 <code>kubectl rollout pause deployment.v1.apps/nginx-deployment</code> 暂停 Deployment，输出结果如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master 0402]# kubectl rollout pause deployment nginx-deployment </span><br><span class="line">deployment.apps&#x2F;nginx-deployment paused</span><br></pre></td></tr></table></figure><p>执行命令 <code>kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.17.9</code>，更新 Deployment 的容器镜像，输出结果如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master 0402]# kubectl set image deployment&#x2F;nginx-deployment nginx&#x3D;nginx:1.17.9</span><br><span class="line">deployment.apps&#x2F;nginx-deployment image updated</span><br></pre></td></tr></table></figure><p>执行命令 <code>kubectl rollout resume deployment/nginx-deployment</code>，继续（resume）该 Deployment，可使前面所有的变更一次性生效，输出结果如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master 0402]# kubectl rollout resume deployment nginx-deployment </span><br><span class="line">deployment.apps&#x2F;nginx-deployment resumed</span><br></pre></td></tr></table></figure><p>执行命令 <code>kubectl get rs -o wide</code> 查看 ResultSet 的最终状态，输出结果如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master 0402]# kubectl get rs -o wide</span><br><span class="line">NAME                          DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         SELECTOR</span><br><span class="line">myapp-57c9b8fc4               2         2         2       3d      nginx        nginx          app&#x3D;myapp,pod-template-hash&#x3D;57c9b8fc4</span><br><span class="line">nginx-deployment-54f57cf6bf   1         1         1       23h     nginx        nginx:1.7.9    app&#x3D;nginx,pod-template-hash&#x3D;54f57cf6bf</span><br><span class="line">nginx-deployment-56f8998dbc   0         0         0       23h     nginx        nginx:1.9.1    app&#x3D;nginx,pod-template-hash&#x3D;56f8998dbc</span><br><span class="line">nginx-deployment-6654964744   5         5         3       5m8s    nginx        nginx:1.17.9   app&#x3D;nginx,pod-template-hash&#x3D;6654964744</span><br></pre></td></tr></table></figure><p>不能回滚（rollback）一个已暂停的 Deployment，除非继续（resume）该 Deployment。 </p><h1 id="七、查看Deployment的状态"><a href="#七、查看Deployment的状态" class="headerlink" title="七、查看Deployment的状态"></a>七、查看Deployment的状态</h1><h2 id="Progressing-状态"><a href="#Progressing-状态" class="headerlink" title="Progressing 状态"></a>Progressing 状态</h2><p>当如下任何一个任务正在执行时，Kubernete 将 Deployment 的状态标记为 <strong><em>progressing</em></strong>：</p><ul><li>Deployment 创建了一个新的 ReplicaSet</li><li>Deployment 正在 scale up 其最新的 ReplicaSet</li><li>Deployment 正在 scale down 其旧的 ReplicaSet</li><li>新的 Pod 变为 <strong><em>就绪（ready）</em></strong> 或 <strong><em>可用（available）</em></strong></li></ul><p>可以使用命令 <code>kubectl rollout status</code> 监控 Deployment 滚动更新的过程</p><h2 id="Complete-状态"><a href="#Complete-状态" class="headerlink" title="Complete 状态"></a>Complete 状态</h2><p>如果 Deployment 符合以下条件，Kubernetes 将其状态标记为 <strong><em>complete</em></strong>：</p><ul><li>该 Deployment 中的所有 Pod 副本都已经被更新到指定的最新版本</li><li>该 Deployment 中的所有 Pod 副本都处于 <strong><em>可用（available）</em></strong> 状态</li><li>该 Deployment 中没有旧的 ReplicaSet 正在运行</li></ul><p>可以执行命令 <code>kubectl rollout status</code> 检查 Deployment 是否已经处于 <strong><em>complete</em></strong> 状态。如果是，则该命令的退出码为 0。 </p><p>例如，执行命令 <code>kubectl rollout status deployment.v1.apps/nginx-deployment</code>，输出结果如下所示：</p><h2 id="Failed-状态"><a href="#Failed-状态" class="headerlink" title="Failed 状态"></a>Failed 状态</h2><p>Deployment 在更新其最新的 ReplicaSet 时，可能卡住而不能达到 <strong><em>complete</em></strong> 状态。如下原因都可能导致此现象发生：</p><ul><li>集群资源不够</li><li>就绪检查（readiness probe）失败</li><li>镜像抓取失败</li><li>权限不够</li><li>资源限制</li><li>应用程序的配置错误导致启动失败</li></ul><p>指定 Deployment 定义中的 <code>.spec.progressDeadlineSeconds</code> 字段，Deployment Controller 在等待指定的时长后，将 Deployment 的标记为处理失败。</p><h2 id="操作处于-Failed-状态的-Deployment"><a href="#操作处于-Failed-状态的-Deployment" class="headerlink" title="操作处于 Failed 状态的 Deployment"></a>操作处于 Failed 状态的 Deployment</h2><p>可以针对 <strong><em>Failed</em></strong> 状态下的 Deployment 执行任何适用于 Deployment 的指令，例如：</p><ul><li>scale up / scale down</li><li>回滚到前一个版本</li><li>暂停（pause）Deployment，以对 Deployment 的 Pod template 执行多处更新</li></ul><h1 id="八、清除策略"><a href="#八、清除策略" class="headerlink" title="八、清除策略"></a>八、清除策略</h1><p>通过 Deployment 中 <code>.spec.revisionHistoryLimit</code> 字段，可指定为该 Deployment 保留多少个旧的 ReplicaSet。超出该数字的将被在后台进行垃圾回收。该字段的默认值是 10。</p><p>如果该字段被设为 0，Kubernetes 将清理掉该 Deployment 的所有历史版本（revision），将无法对该 Deployment 执行回滚操作 <code>kubectl rollout undo</code>。</p><h1 id="九、部署策略"><a href="#九、部署策略" class="headerlink" title="九、部署策略"></a>九、部署策略</h1><p> 通过 Deployment 中 <code>.spec.strategy</code> 字段，可以指定使用 <code>滚动更新 RollingUpdate</code> 的部署策略还是使用 <code>重新创建 Recreate</code> 的部署策略 </p><p>其中字段的含义如下：</p><table><thead><tr><th>字段名称</th><th>可选值</th><th>字段描述</th></tr></thead><tbody><tr><td>类型</td><td>滚动更新 重新创建</td><td>如果选择重新创建，Deployment将先删除原有副本集中的所有 Pod，然后再创建新的副本集和新的 Pod。如此，更新过程中将出现一段应用程序不可用的情况；</td></tr><tr><td>最大超出副本数</td><td>数字或百分比</td><td>滚动更新过程中，可以超出期望副本数的最大值。 该取值可以是一个绝对值（例如：5），也可以是一个相对于期望副本数的百分比（例如：10%）； 如果填写百分比，则以期望副本数乘以该百分比后向上取整的方式计算对应的绝对值； 当最大超出副本数 maxUnavailable 为 0 时，此数值不能为 0；默认值为 25%。 例如：假设此值被设定为 30%，当滚动更新开始时，新的副本集（ReplicaSet）可以立刻扩容， 但是旧 Pod 和新 Pod 的总数不超过 Deployment 期待副本数（spec.repilcas）的 130%。 一旦旧 Pod 被终止后，新的副本集可以进一步扩容，但是整个滚动更新过程中，新旧 Pod 的总 数不超过 Deployment 期待副本数（spec.repilcas）的 130%。</td></tr><tr><td>最大不可用副本数</td><td>数字或百分比</td><td>滚动更新过程中，不可用副本数的最大值。 该取值可以是一个绝对值（例如：5），也可以是一个相对于期望副本数的百分比（例如：10%）； 如果填写百分比，则以期望副本数乘以该百分比后向下取整的方式计算对应的绝对值； 当最大超出副本数 maxSurge 为 0 时，此数值不能为 0；默认值为 25%； 例如：假设此值被设定为 30%，当滚动更新开始时，旧的副本集（ReplicaSet）可以缩容到期望 副本数的 70%；在新副本集扩容的过程中，一旦新的 Pod 已就绪，旧的副本集可以进一步缩容， 整个滚动更新过程中，确保新旧就绪副本数之和不低于期望副本数的 70%。</td></tr></tbody></table><h1 id="十、金丝雀发布（灰度发布）"><a href="#十、金丝雀发布（灰度发布）" class="headerlink" title="十、金丝雀发布（灰度发布）"></a>十、金丝雀发布（灰度发布）</h1><p>可以使用 Deployment 将最新的应用程序版本发布给一部分用户（或服务器），为每个版本创建一个 Deployment，此时，应用程序的新旧两个版本都可以同时获得生产上的流量。 </p><p>部署第一个版本</p><p>第一个版本的 Deployment 包含了 3 个Pod副本，Service 通过 label selector <code>app: nginx</code> 选择对应的 Pod，nginx 的标签为 <code>1.7.9</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">32600</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure><p> 假设此时想要发布新的版本 nginx <code>1.8.0</code>，可以创建第二个 Deployment： </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment-canary</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">track:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">track:</span> <span class="string">canary</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">track:</span> <span class="string">canary</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.8.0</span></span><br></pre></td></tr></table></figure><ul><li>因为 Service 的LabelSelector 是 <code>app: nginx</code>，由 <code>nginx-deployment</code> 和 <code>nginx-deployment-canary</code> 创建的 Pod 都带有标签 <code>app: nginx</code>，所以，Service 的流量将会在两个 release 之间分配</li><li>在新旧版本之间，流量分配的比例为两个版本副本数的比例，此处为 1:3</li></ul><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>按照 Kubernetes 默认支持的这种方式进行金丝雀发布，有一定的局限性：</p><ul><li>不能根据用户注册时间、地区等请求中的内容属性进行流量分配</li><li>同一个用户如果多次调用该 Service，有可能第一次请求到了旧版本的 Pod，第二次请求到了新版本的 Pod</li></ul><p>在 Kubernetes 中不能解决上述局限性的原因是：Kubernetes Service 只在 TCP 层面解决负载均衡的问题，并不对请求响应的消息内容做任何解析和识别。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;控制器-Deployment&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>控制器 - ReplicaSet</title>
    <link href="http://yoursite.com/2020/04/01/%E6%8E%A7%E5%88%B6%E5%99%A8-ReplicaSet/"/>
    <id>http://yoursite.com/2020/04/01/%E6%8E%A7%E5%88%B6%E5%99%A8-ReplicaSet/</id>
    <published>2020-04-01T06:57:39.000Z</published>
    <updated>2020-04-07T08:12:34.023Z</updated>
    
    <content type="html"><![CDATA[<p> 控制器概述及控制器-ReplicaSet</p><a id="more"></a> <h1 id="控制器-概述"><a href="#控制器-概述" class="headerlink" title="控制器_概述"></a>控制器_概述</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Pod（容器组）是 Kubernetes 中最小的调度单元，可以通过 kubectl 直接创建一个 Pod。Pod 本身并不能自愈（self-healing）。如果一个 Pod 所在的 Node （节点）出现故障，或者调度程序自身出现故障，Pod 将被删除；同理，当因为节点资源不够或节点维护而驱逐 Pod 时，Pod 也将被删除。</p><p>Kubernetes 通过引入 Controller（控制器）的概念来管理 Pod 实例。在 Kubernetes 中，创建 Pod 始终应该用 Controller 来创建 Pod，而不是直接创建 Pod。</p><p>Pod控制器是用于实现管理 Pod 的中间层，确保 Pod 资源符合预期的状态，Pod 的资源出现故障时，会尝试进行重启，当根据重启策略无效，则会重新新建 Pod 的资源.。</p><p><strong>控制器可以提供如下特性：</strong></p><ul><li>水平扩展（运行 Pod 的多个副本）</li><li>rollout（版本更新）</li><li>self-healing（故障恢复） 例如：当一个节点出现故障，控制器可以自动地在另一个节点调度一个配置完全一样的 Pod，以替换故障节点上的 Pod。</li></ul><h2 id="控制器类型"><a href="#控制器类型" class="headerlink" title="控制器类型"></a>控制器类型</h2><ul><li><strong>控制器-ReplicaSet：</strong> 代用户创建指定数量的pod副本数量，确保pod副本数量符合预期状态，并且支持滚动式自动扩容和缩容功能。<br>ReplicaSet主要三个组件组成：<br>　　（1）用户期望的pod副本数量<br>　　（2）标签选择器，判断哪个pod归自己管理<br>　　（3）当现存的pod数量不足，会根据pod资源模板进行新建<br>帮助用户管理无状态的pod资源，精确反应用户定义的目标数量，但是RelicaSet不是直接使用的控制器，而是使用Deployment。 </li><li><strong>控制器-Deployment：</strong> 工作在ReplicaSet之上，用于管理无状态应用，目前来说最好的控制器。支持滚动更新和回滚功能，还提供声明式配置。 </li><li><strong>控制器-StatefulSet：</strong> 周期性任务控制，不需要持续后台运行 </li><li><strong>控制器-DaemonSet：</strong> 用于确保集群中的每一个节点只运行特定的pod副本，通常用于实现系统级后台任务。比如ELK服务<br>特性：服务是无状态的<br>服务必须是守护进程 </li><li><strong>控制器-Job：</strong> 只要完成就立即退出，不需要重启或重建。 </li><li><strong>控制器CronJob：</strong> 周期性任务控制，不需要持续后台运行 </li></ul><h1 id="控制器-ReplicaSet"><a href="#控制器-ReplicaSet" class="headerlink" title="控制器 - ReplicaSet"></a>控制器 - ReplicaSet</h1><p>Kubernetes 中，ReplicaSet 用来维护一个数量稳定的 Pod 副本集合，可以保证某种定义一样的 Pod 始终有指定数量的副本数在运行。 </p><h2 id="ReplicaSet的工作方式"><a href="#ReplicaSet的工作方式" class="headerlink" title="ReplicaSet的工作方式"></a>ReplicaSet的工作方式</h2><p>ReplicaSet的定义中，包含：</p><ul><li><code>selector</code>： 用于指定哪些 Pod 属于该 ReplicaSet 的管辖范围</li><li><code>replicas</code>： 副本数，用于指定该 ReplicaSet 应该维持多少个 Pod 副本</li><li><code>template</code>： Pod模板，在 ReplicaSet 使用 Pod 模板的定义创建新的 Pod</li></ul><p>ReplicaSet 控制器将通过创建或删除 Pod，以使得当前 Pod 数量达到 <code>replicas</code> 指定的期望值。ReplicaSet 创建的 Pod 中，都有一个字段 metadata.ownerReferences 用于标识该 Pod 从属于哪一个 ReplicaSet。</p><p>ReplicaSet 通过 <code>selector</code> 字段的定义，识别哪些 Pod 应该由其管理。如果 Pod 没有 ownerReference 字段，或者 ownerReference 字段指向的对象不是一个控制器，且该 Pod 匹配了 ReplicaSet 的 <code>selector</code>，则该 Pod 的 ownerReference 将被修改为 该 ReplicaSet 的引用。</p><h2 id="何时使用-ReplicaSet"><a href="#何时使用-ReplicaSet" class="headerlink" title="何时使用 ReplicaSet"></a>何时使用 ReplicaSet</h2><p>ReplicaSet 用来维护一个数量稳定的 Pod 副本集合。Deployment 可以管理 ReplicaSet，并提供声明式的更新等。因此，推荐用户总是使用 Deployment，而不是直接使用 ReplicaSet，除非需要一些自定义的更新应用程序的方式，或者完全不更新应用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">guestbook</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># modify replicas according to your case</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>ReplicaSet 副本集的主要几个字段有：</p><ul><li>selector 确定哪些 Pod 属于该副本集</li><li>replicas 副本集应该维护几个 Pod 副本（实例）</li><li>template Pod 的定义</li></ul><p>副本集将通过创建、删除 Pod 容器组来确保符合 selector 选择器的 Pod 数量等于 replicas 指定的数量。当符合 selector 选择器的 Pod 数量不够时，副本集通过使用 template 中的定义来创建 Pod。</p><p>执行命令以创建该 YAML 对应的 ReplicaSet </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master k8s-yamls]# kubectl apply -f rs.yaml </span><br><span class="line">replicaset.apps&#x2F;frontend created</span><br><span class="line">[root@k8s-master k8s-yamls]# kubectl get rs</span><br><span class="line">NAME                  DESIRED   CURRENT   READY   AGE</span><br><span class="line">frontend              3         3         1       10s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@k8s-master k8s-yamls]# kubectl describe rs&#x2F;frontend</span><br><span class="line">Name:         frontend</span><br><span class="line">Namespace:    default</span><br><span class="line">Selector:     tier&#x3D;frontend</span><br><span class="line">Labels:       app&#x3D;guestbook</span><br><span class="line">              tier&#x3D;frontend</span><br><span class="line">Annotations:  kubectl.kubernetes.io&#x2F;last-applied-configuration:</span><br><span class="line">                &#123;&quot;apiVersion&quot;:&quot;apps&#x2F;v1&quot;,&quot;kind&quot;:&quot;ReplicaSet&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;labels&quot;:&#123;&quot;app&quot;:&quot;guestbook&quot;,&quot;tier&quot;:&quot;frontend&quot;&#125;,&quot;name&quot;:&quot;frontend&quot;,...</span><br><span class="line">Replicas:     3 current &#x2F; 3 desired</span><br><span class="line">Pods Status:  2 Running &#x2F; 1 Waiting &#x2F; 0 Succeeded &#x2F; 0 Failed</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  tier&#x3D;frontend</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:        nginx</span><br><span class="line">    Port:         &lt;none&gt;</span><br><span class="line">    Host Port:    &lt;none&gt;</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason            Age    From                   Message</span><br><span class="line"></span><br><span class="line">----    ------            ----   ----                   -------</span><br><span class="line"></span><br><span class="line">  Normal  SuccessfulCreate  2m58s  replicaset-controller  Created pod: frontend-fsfrx</span><br><span class="line">  Normal  SuccessfulCreate  2m58s  replicaset-controller  Created pod: frontend-72vr4</span><br><span class="line">  Normal  SuccessfulCreate  2m58s  replicaset-controller  Created pod: frontend-zp2k8</span><br></pre></td></tr></table></figure><h2 id="ReplicaSet的定义"><a href="#ReplicaSet的定义" class="headerlink" title="ReplicaSet的定义"></a>ReplicaSet的定义</h2><p>与其他 Kubernetes 对象一样，ReplicaSet需要的字段有：</p><ul><li><code>apiVersion</code>：apps/v1</li><li><code>kind</code>：始终为 ReplicaSet</li><li><code>metadata</code></li><li><code>spec</code>： ReplicaSet 的详细定义</li></ul><h3 id="PodTemplate"><a href="#PodTemplate" class="headerlink" title="PodTemplate"></a>PodTemplate</h3><p><code>.spec.template</code> 字段是一个 Pod Template，为必填字段，且其中必须定义 <code>.spec.template.metadata.labels</code> 字段。在前面的ReplicaSet例子中，定义了 label 为 <code>tier: frontend</code>。请小心该字段不要与其他控制器的 selector 重合，以免这些控制器尝试接管该 Pod。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.spec.template.spec.restartPolicy&#96; 的默认值为 &#96;Always</span><br></pre></td></tr></table></figure><h3 id="Pod-Selector"><a href="#Pod-Selector" class="headerlink" title="Pod Selector"></a>Pod Selector</h3><p><code>.spec.selector</code> 字段为一个标签选择器，用于识别可以接管哪些 Pod。在前面的例子中，标签选择器为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">matchLabels:</span></span><br><span class="line"><span class="attr">tier:</span> <span class="string">frontend</span></span><br></pre></td></tr></table></figure><p>在 ReplicaSet 中， <code>.spec.template.metadata.labels</code> 必须与 <code>.spec.selector</code> 匹配，否则将不能成功创建 ReplicaSet。</p><p>如果两个 ReplicaSet 指定了相同的 <code>.spec.selector</code> 但是不同的 <code>.spec.template.metadata.labels</code> 和不同的 <code>.spec.tempalte.spec</code> 字段，两个 ReplicaSet 都将忽略另外一个 ReplicaSet 创建的 Pod</p><h3 id="Replicas"><a href="#Replicas" class="headerlink" title="Replicas"></a>Replicas</h3><p><code>.spec.replicas</code> 字段用于指定同时运行的 Pod 的副本数。ReplicaSet 将创建或者删除由其管理的 Pod，以便使副本数与该字段指定的值匹配。</p><p>如果不指定，默认值为 1</p><h2 id="使用-ReplicaSet"><a href="#使用-ReplicaSet" class="headerlink" title="使用 ReplicaSet"></a>使用 ReplicaSet</h2><h3 id="删除ReplicaSet及其Pod"><a href="#删除ReplicaSet及其Pod" class="headerlink" title="删除ReplicaSet及其Pod"></a>删除ReplicaSet及其Pod</h3><p>使用 <code>kubectl delete</code> 可删除 ReplicaSet， Garbage Collector将自动删除该 ReplicaSet 所有从属的 Pod。</p><h3 id="只删除ReplicaSet"><a href="#只删除ReplicaSet" class="headerlink" title="只删除ReplicaSet"></a>只删除ReplicaSet</h3><p>使用 <code>kubectl delete --cascade=false</code> 命令，可以删除 ReplicaSet，但是仍然保留其 Pod。</p><p>一旦原来的 ReplicaSet 被删除，可以创建新的 ReplicaSet 作为替代。只要新 ReplicaSet 的 <code>.spec.selector</code> 字段与旧 ReplicaSet 的 <code>.spec.selector</code> 字段相同，则新的 ReplicaSet 将接管旧 ReplicaSet 遗留下来的 Pod。但是，新的 ReplicaSet 中定义的 <code>.spec.template</code> 对遗留下来的 Pod 不会产生任何影响。 </p><h3 id="将Pod从ReplicaSet中隔离"><a href="#将Pod从ReplicaSet中隔离" class="headerlink" title="将Pod从ReplicaSet中隔离"></a>将Pod从ReplicaSet中隔离</h3><p>修改 Pod 的标签，可以使 Pod 脱离 ReplicaSet 的管理。这个小技巧在如下场景可能非常有用：</p><ul><li>将 Pod 从 Service 中移除，以便 Debug 或者做数据恢复</li></ul><p>通过这种方式从 ReplicaSet 移除了 Pod 之后，ReplicaSet 将立刻自动创建一个新的 Pod 以维持其指定的 <code>replicas</code> 副本数。</p><h3 id="ReplicaSet的自动伸缩"><a href="#ReplicaSet的自动伸缩" class="headerlink" title="ReplicaSet的自动伸缩"></a>ReplicaSet的自动伸缩</h3><p>可以使用 Horizontal Pod Autoscalers(HPA) 对 ReplicaSet 执行自动的水平伸缩。下面例子中的 HPA 可以用来对前面例子中的 ReplicaSet 执行自动的水平伸缩：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend-scaler</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure><p>此外，也可以使用 <code>kubectl autoscale</code> 命令达到相同的效果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl autoscale rs frontend --max=10</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 控制器概述及控制器-ReplicaSet&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s应用健康状态</title>
    <link href="http://yoursite.com/2020/04/01/K8s%E5%BA%94%E7%94%A8%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2020/04/01/K8s%E5%BA%94%E7%94%A8%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81/</id>
    <published>2020-04-01T06:10:31.000Z</published>
    <updated>2020-04-01T06:52:54.190Z</updated>
    
    <content type="html"><![CDATA[<p> 应用健康状态和常见应用异常；</p><a id="more"></a> <h1 id="应用健康状态"><a href="#应用健康状态" class="headerlink" title="应用健康状态"></a>应用健康状态</h1><h2 id="应用健康状态-使用方式"><a href="#应用健康状态-使用方式" class="headerlink" title="应用健康状态-使用方式"></a>应用健康状态-使用方式</h2><h4 id="探测方式"><a href="#探测方式" class="headerlink" title="探测方式"></a>探测方式</h4><p>Liveness 指针和 Readiness 指针支持三种不同的探测方式：</p><ol><li>第一种是 httpGet。它是通过发送 http Get 请求来进行判断的，当返回码是 200-399 之间的状态码时，标识这个应用是健康的；</li><li>第二种探测方式是 Exec。它是通过执行容器中的一个命令来判断当前的服务是否是正常的，当命令行的返回结果是 0，则标识容器是健康的；</li><li>第三种探测方式是 tcpSocket 。它是通过探测容器的 IP 和 Port 进行 TCP 健康检查，如果这个 TCP 的链接能够正常被建立，那么标识当前这个容器是健康的。</li></ol><h4 id="探测结果"><a href="#探测结果" class="headerlink" title="探测结果"></a>探测结果</h4><p>从探测结果来讲主要分为三种：</p><ul><li>第一种是 success，当状态是 success 的时候，表示 container 通过了健康检查，也就是 Liveness probe 或 Readiness probe 是正常的一个状态；</li><li>第二种是 Failure，Failure 表示的是这个 container 没有通过健康检查，如果没有通过健康检查的话，那么此时就会进行相应的一个处理，那在 Readiness 处理的一个方式就是通过 service。service 层将没有通过 Readiness 的 pod 进行摘除，而 Liveness 就是将这个 pod 进行重新拉起，或者是删除。</li><li>第三种状态是 Unknown，Unknown 是表示说当前的执行的机制没有进行完整的一个执行，可能是因为类似像超时或者像一些脚本没有及时返回，那么此时 Readiness-probe 或 Liveness-probe 会不做任何的一个操作，会等待下一次的机制来进行检验。</li></ul><p>那在 kubelet 里面有一个叫 ProbeManager 的组件，这个组件里面会包含 Liveness-probe 或 Readiness-probe，这两个 probe 会将相应的 Liveness 诊断和 Readiness 诊断作用在 pod 之上，来实现一个具体的判断。</p><h3 id="应用健康状态-Pod-Probe-Spec"><a href="#应用健康状态-Pod-Probe-Spec" class="headerlink" title="应用健康状态-Pod Probe Spec"></a>应用健康状态-Pod Probe Spec</h3><p><strong>exec：</strong>如下图所示，可以看到这是一个 Liveness probe，它里面配置了一个 exec 的一个诊断。接下来，它又配置了一个 command 的字段，这个 command 字段里面通过 cat 一个具体的文件来判断当前 Liveness probe 的状态，当这个文件里面返回的结果是 0 时，或者说这个命令返回是 0 时，它会认为此时这个 pod 是处在健康的一个状态。 </p><p> <img src="https://kuboard.cn/assets/img/1936763b70d81b10f9e14c2f612819ed19865cf6.c7aeb95b.png" alt="4"> </p><p><strong>httpGet：</strong>httpGet 里面有一个字段是路径，第二个字段是 port，第三个是 headers。这个地方有时需要通过类似像 header 头的一个机制做 health 的一个判断时，需要配置这个 header，通常情况下，可能只需要通过 health 和 port 的方式就可以了。 </p><p> <img src="https://kuboard.cn/assets/img/f1053686bdb48dc98171a06351be4d5f139218b1.7b257b18.png" alt="5"> </p><p><strong>tcpSocket：</strong>tcpSocket 的使用方式其实也比较简单，只需要设置一个检测的端口，像下图使用的是 8080 端口，当这个 8080 端口 tcp connect 审核正常被建立的时候，那 tecSocket，Probe 会认为是健康的一个状态。 </p><p> <img src="https://kuboard.cn/assets/img/7f2a4c83600974bf9e6c7007c848e3eaad3b239d.7b0422c1.png" alt="6"> </p><p>此外还有如下的五个参数，是 Global 的参数。</p><ol><li>initialDelaySeconds：它表示的是说这个 pod 启动延迟多久进行一次检查，比如说现在有一个 Java 的应用，它启动的时间可能会比较长，因为涉及到 jvm 的启动，包括 Java 自身 jar 的加载。所以前期，可能有一段时间是没有办法被检测的，而这个时间又是可预期的，那这时可能要设置一下 initialDelaySeconds；</li><li>periodSeconds：它表示的是检测的时间间隔，正常默认的这个值是 10 秒；</li><li>timeoutSeconds：它表示的是检测的超时时间，当超时时间之内没有检测成功，那它会认为是失败的一个状态；</li><li>successThreshold：它表示的是：当这个 pod 从探测失败到再一次判断探测成功，所需要的阈值次数，默认情况下是 1 次，表示原本是失败的，那接下来探测这一次成功了，就会认为这个 pod 是处在一个探针状态正常的一个状态；</li><li>failureThreshold：它表示的是探测失败的重试次数，默认值是 3，表示的是当从一个健康的状态连续探测 3 次失败，那此时会判断当前这个pod的状态处在一个失败的状态。</li></ol><h3 id="应用健康状态-Liveness-与-Readiness-总结"><a href="#应用健康状态-Liveness-与-Readiness-总结" class="headerlink" title="应用健康状态-Liveness 与 Readiness 总结"></a>应用健康状态-Liveness 与 Readiness 总结</h3><table><thead><tr><th></th><th>Liveness</th><th>Readness</th></tr></thead><tbody><tr><td><strong>介绍</strong></td><td>用于判断容器是否存活，即Pod状态是否为Running，如果Liveness指针判断容器不健康则会触发kubelet杀掉容器，并根据配置的策略判断是否重启容器，如果默认不配置Liveness探针，则任务返回值默认为成功</td><td>用于判断容器是否启动完成，即Pod的Condition是否为Ready，如果探测结果不成功，则会将Pod从Endpoint中移除，直至下次判断成功，再将Pod挂回到Endpoint上。</td></tr><tr><td><strong>检测失败</strong></td><td>杀掉Pod</td><td>切断上层流量到Pod</td></tr><tr><td><strong>适用场景</strong></td><td>支持重新拉起的应用</td><td>启动后无法立即对外服务的应用</td></tr><tr><td><strong>注意事项</strong></td><td>不论是Liveness还是Readness探针，选择适合的探测方式可以防止被误操作 1.调大判断的差事阙值，防止在容器压力较高的情况下出现偶发超时 2.调整判断的次数阙值，3次的默认值在短周期下不一定是最佳实践 3.exec的如果执行的是shell脚本判断，在容器中可能调用时间会非常长 4.使用tcpSocket的方式遇到TLS的场景，需要业务层判断是否有影响</td><td></td></tr></tbody></table><h3 id="应用故障排查-了解状态机制"><a href="#应用故障排查-了解状态机制" class="headerlink" title="应用故障排查-了解状态机制"></a>应用故障排查-了解状态机制</h3><p>因为 K8S 的设计是面向状态机的，它里面通过 yaml 的方式来定义的是一个期望到达的一个状态，而真正这个 yaml 在执行过程中会由各种各样的 controller来负责整体的状态之间的一个转换。</p><table><thead><tr><th>Phase</th><th>描述</th></tr></thead><tbody><tr><td>Pending</td><td>Kubernetes 已经创建并确认该 Pod。此时可能有两种情况：Pod 还未完成调度（例如没有合适的节点）正在从 docker registry 下载镜像</td></tr><tr><td>Running</td><td>该 Pod 已经被绑定到一个节点，并且该 Pod 所有的容器都已经成功创建。其中至少有一个容器正在运行，或者正在启动/重启</td></tr><tr><td>Succeeded</td><td>Pod 中的所有容器都已经成功终止，并且不会再被重启</td></tr><tr><td>Failed</td><td>Pod 中的所有容器都已经终止，至少一个容器终止于失败状态：容器的进程退出码不是 0，或者被系统 kill</td></tr><tr><td>Unknown</td><td>因为某些未知原因，不能确定 Pod 的状态，通常的原因是 master 与 Pod 所在节点之间的通信故障</td></tr></tbody></table><h3 id="用故障排查-常见应用异常"><a href="#用故障排查-常见应用异常" class="headerlink" title="用故障排查-常见应用异常"></a>用故障排查-常见应用异常</h3><p>pod 上面可能会停留几个常见的状态。</p><h4 id="Pod-停留在-Pending"><a href="#Pod-停留在-Pending" class="headerlink" title="Pod 停留在 Pending"></a>Pod 停留在 Pending</h4><p>第一个就是 pending 状态，pending 表示调度器没有进行介入。此时可以通过 kubectl describe pod 来查看相应的事件，如果由于资源或者说端口占用，或者是由于 node selector 造成 pod 无法调度的时候，可以在相应的事件里面看到相应的结果，这个结果里面会表示说有多少个不满足的 node，有多少是因为 CPU 不满足，有多少是由于 node 不满足，有多少是由于 tag 打标造成的不满足。</p><h4 id="Pod-停留在-waiting"><a href="#Pod-停留在-waiting" class="headerlink" title="Pod 停留在 waiting"></a>Pod 停留在 waiting</h4><p>那第二个状态就是 pod 可能会停留在 waiting 的状态，pod 的 states 处在 waiting 的时候，通常表示说这个 pod 的镜像没有正常拉取，原因可能是由于这个镜像是私有镜像，但是没有配置 Pod secret；那第二种是说可能由于这个镜像地址是不存在的，造成这个镜像拉取不下来；还有一个是说这个镜像可能是一个公网的镜像，造成镜像的拉取失败。</p><h4 id="Pod-不断被拉取并且可以看到-crashing"><a href="#Pod-不断被拉取并且可以看到-crashing" class="headerlink" title="Pod 不断被拉取并且可以看到 crashing"></a>Pod 不断被拉取并且可以看到 crashing</h4><p>第三种是 pod 不断被拉起，而且可以看到类似像 backoff 。这个通常表示说 pod 已经被调度完成了，但是启动失败，那这个时候通常要关注的应该是这个应用自身的一个状态，并不是说配置是否正确、权限是否正确，此时需要查看的应该是 pod 的具体日志。</p><h4 id="Pod-处在-Runing-但是没有正常工作"><a href="#Pod-处在-Runing-但是没有正常工作" class="headerlink" title="Pod 处在 Runing 但是没有正常工作"></a>Pod 处在 Runing 但是没有正常工作</h4><p>第四种 pod 处在 running 状态，但是没有正常对外服务。那此时比较常见的一个点就可能是由于一些非常细碎的配置，类似像有一些字段可能拼写错误，造成了 yaml 下发下去了，但是有一段没有正常地生效，从而使得这个 pod 处在 running 的状态没有对外服务，那此时可以通过 apply-validate-f pod.yaml 的方式来进行判断当前 yaml 是否是正常的，如果 yaml 没有问题，那么接下来可能要诊断配置的端口是否是正常的，以及 Liveness 或 Readiness 是否已经配置正确。</p><h4 id="Service-无法正常的工作"><a href="#Service-无法正常的工作" class="headerlink" title="Service 无法正常的工作"></a>Service 无法正常的工作</h4><p>最后一种就是 service 无法正常工作的时候，该怎么去判断呢？那比较常见的 service 出现问题的时候，是自己的使用上面出现了问题。因为 service 和底层的 pod 之间的关联关系是通过 selector 的方式来匹配的，也就是说 pod 上面配置了一些 label，然后 service 通过 match label 的方式和这个 pod 进行相互关联。如果这个 label 配置的有问题，可能会造成这个 service 无法找到后面的 endpoint，从而造成相应的 service 没有办法对外提供服务，那如果 service 出现异常的时候，第一个要看的是这个 service 后面是不是有一个真正的 endpoint，其次来看这个 endpoint 是否可以对外提供正常的服务。</p><h3 id="开源的调试工具-kubectl-debug"><a href="#开源的调试工具-kubectl-debug" class="headerlink" title="开源的调试工具 - kubectl-debug"></a>开源的调试工具 - kubectl-debug</h3><p> kubectl-debug 这个工具是依赖于 Linux namespace 的方式来去做的，它可以 datash 一个 Linux namespace 到一个额外的 container，然后在这个 container 里面执行任何的 debug 动作，其实和直接去 debug 这个 Linux namespace 是一致的。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>关于 Liveness 和 Readiness 的指针。Liveness probe 就是保活指针，它是用来看 pod 是否存活的，而 Readiness probe 是就绪指针，它是判断这个 pod 是否就绪的，如果就绪了，就可以对外提供服务。这个就是 Liveness 和 Readiness 需要记住的部分；</li><li>应用诊断的三个步骤：首先 describe 相应的一个状态；然后提供状态来排查具体的一个诊断方向；最后来查看相应对象的一个 event 获取更详细的一个信息；</li><li>提供 pod 一个日志来定位应用的自身的一个状态；</li><li>远程调试的一个策略，如果想把本地的应用代理到远程集群，此时可以通过 Telepresence 这样的工具来实现，如果想把远程的应用代理到本地，然后在本地进行调用或者是调试，可以用类似像 port-forward 这种机制来实现</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 应用健康状态和常见应用异常；&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s容器组 Pod</title>
    <link href="http://yoursite.com/2020/03/31/K8s%E5%AE%B9%E5%99%A8%E7%BB%84/"/>
    <id>http://yoursite.com/2020/03/31/K8s%E5%AE%B9%E5%99%A8%E7%BB%84/</id>
    <published>2020-03-31T07:06:33.000Z</published>
    <updated>2020-04-01T06:07:02.600Z</updated>
    
    <content type="html"><![CDATA[<p>Pod的相关理解</p> <a id="more"></a> <h1 id="一、Pod-容器组-概述"><a href="#一、Pod-容器组-概述" class="headerlink" title="一、Pod 容器组_概述"></a>一、Pod 容器组_概述</h1><h2 id="什么是-Pod-容器组"><a href="#什么是-Pod-容器组" class="headerlink" title="什么是 Pod 容器组"></a>什么是 Pod 容器组</h2><p>Pod（容器组）是 Kubernetes 中最小的可部署单元。</p><p>一个 Pod（容器组）包含了一个应用程序容器（某些情况下是多个容器）、存储资源、一个唯一的网络 IP 地址、以及一些确定容器该如何运行的选项。</p><p>Pod 容器组代表了 Kubernetes 中一个独立的应用程序运行实例，该实例可能由单个容器或者几个紧耦合在一起的容器组成。</p><p>Kubernetes 集群中的 Pod 存在如下两种使用途径：</p><ul><li>一个 Pod 中只运行一个容器。”one-container-per-pod” 是 Kubernetes 中最常见的使用方式。Kubernetes 通过 Pod 管理容器，而不是直接管理容器。</li><li>一个 Pod 中运行多个需要互相协作的容器。可以将多个紧密耦合、共享资源且始终在一起运行的容器编排在同一个 Pod 中。</li></ul><p>每一个 Pod 都是用来运行某一特定应用程序的一个实例。如果想要水平扩展应用程序（运行多个实例），运行多个 Pod 容器组，每一个代表应用程序的一个实例。</p><ul><li>Kubernetes 中，称其为 replication（复制副本）。</li><li>Kubernetes 中 Controller（控制器）负责为应用程序创建和管理这些复制的副本。 </li></ul><h2 id="Pod-如何管理多个容器"><a href="#Pod-如何管理多个容器" class="headerlink" title="Pod 如何管理多个容器"></a>Pod 如何管理多个容器</h2><p>Pod 的设计目的是用来支持多个互相协同的容器，使得形成一个有意义的服务单元。一个 Pod 中的多个容器很自然就可以随 Pod 被一起调度到集群中的同一个物理机或虚拟机上。Pod 中的容器可以：</p><ul><li>共享资源、依赖</li><li>互相通信</li><li>相互协商何时以何种方式结束运行</li></ul><p><strong>Pod 为其成员容器提供了两种类型的共享资源：网络和存储</strong></p><ul><li><p>网络 Networking</p><p>每一个 Pod 被分配一个独立的 IP 地址。Pod 中的所有容器共享一个网络名称空间：</p></li></ul><ol><li>​    同一个 Pod 中的所有容器 IP 地址都相同</li><li>​    同一个 Pod 中的不同容器不能使用相同的端口，否则会导致端口冲突</li><li>​    同一个 Pod 中的不同容器可以通过 localhost:port 进行通信</li><li>​    同一个 Pod 中的不同容器可以通过使用常规的进程间通信手段，例如 SystemV semaphores 或者 POSIX 共享内存</li></ol><ul><li>存储 Storage</li></ul><p>Pod 中可以定义一组共享的数据卷。Pod 中所有的容器都可以访问这些共享数据卷，以便共享数据。Pod 中数据卷的数据也可以存储持久化的数据，使得容器在重启后仍然可以访问到之前存入到数据卷中的数据。</p><p><code>不同 Pod 上的两个容器如果要通信，必须使用对方 Pod 的 IP 地址 + 对方容器的端口号进行网络通信</code> </p><h2 id="使用-Pod"><a href="#使用-Pod" class="headerlink" title="使用 Pod"></a>使用 Pod</h2><p> 在 Pod 被创建后（直接创建，或者间接通过 Controller 创建），将被调度到集群中的一个节点上运行。Pod 将一直保留在该节点上，直到 Pod 以下情况发生： </p><ul><li><p>Pod 中的容器全部结束运行</p></li><li><p>Pod 被删除</p></li><li><p>由于节点资源不够，Pod 被驱逐</p></li><li><p>节点出现故障（例如死机）</p></li><li><input disabled="" type="checkbox"> <p>Pod 本身并不会运行，Pod 仅仅是容器运行的一个环境 </p></li></ul><p>Pod 本身并不能自愈（self-healing）。如果一个 Pod 所在的 Node （节点）出现故障，或者调度程序自身出现故障，Pod 将被删除；同理，当因为节点资源不够或节点维护而驱逐 Pod 时，Pod 也将被删除。Kubernetes 通过引入 Controller（控制器）的概念来管理 Pod 实例。在 Kubernetes 中，更为推荐的做法是使用 Controller 来管理 Pod，而不是直接创建 Pod。 </p><h2 id="容器组和控制器"><a href="#容器组和控制器" class="headerlink" title="容器组和控制器"></a>容器组和控制器</h2><p>用户应该始终使用控制器来创建 Pod，而不是直接创建 Pod，控制器可以提供如下特性：</p><ul><li><p>水平扩展（运行 Pod 的多个副本）</p></li><li><p>rollout（版本更新）</p></li><li><p>self-healing（故障恢复）</p><p>例如：当一个节点出现故障，控制器可以自动地在另一个节点调度一个配置完全一样的 Pod，以替换故障节点上的 Pod。</p></li></ul><p>在 Kubernetes 中，广泛使用的控制器有：</p><ul><li>Deployment</li><li>StatefulSet</li><li>DaemonSet</li></ul><h2 id="Termination-of-Pods（终止Pod）"><a href="#Termination-of-Pods（终止Pod）" class="headerlink" title="Termination of Pods（终止Pod）"></a>Termination of Pods（终止Pod）</h2><p>Pod 代表了运行在集群节点上的进程，而进程的终止有两种方式：</p><ul><li>gracefully terminate （优雅地终止）</li><li>直接 kill，此时进程没有机会执行清理动作</li></ul><p><strong>当用户发起删除 Pod 的指令时，Kubernetes 需要：</strong></p><ul><li>让用户知道 Pod 何时被删除</li><li>确保删除 Pod 的指令最终能够完成</li></ul><p><strong>Kubernetes 收到用户删除 Pod 的指令后：</strong></p><ol><li>记录强制终止前的等待时长（grace period）</li><li>向 Pod 中所有容器的主进程发送 TERM 信号</li><li>一旦等待超时，向超时的容器主进程发送 KILL 信号</li><li>删除 Pod 在 API Server 中的记录</li></ol><p>默认情况下，删除 Pod 的 grace period（等待时长）是 30 秒。</p><p>可以通过 kubectl delete 命令的选项 <code>--grace-period=</code> 自己指定 grace period（等待时长）。</p><p>强制删除 Pod，必须为 kubectl delete 命令同时指定两个选项 <code>--grace-period=0</code> 和 <code>--force</code> </p><h1 id="二、Pod-容器组-声明周期"><a href="#二、Pod-容器组-声明周期" class="headerlink" title="二、Pod 容器组_声明周期"></a>二、Pod 容器组_声明周期</h1><h2 id="Pod-phase"><a href="#Pod-phase" class="headerlink" title="Pod phase"></a>Pod phase</h2><table><thead><tr><th>Phase</th><th>描述</th></tr></thead><tbody><tr><td>Pending</td><td>Kubernetes 已经创建并确认该 Pod。此时可能有两种情况：Pod 还未完成调度（例如没有合适的节点）正在从 docker registry 下载镜像</td></tr><tr><td>Running</td><td>该 Pod 已经被绑定到一个节点，并且该 Pod 所有的容器都已经成功创建。其中至少有一个容器正在运行，或者正在启动/重启</td></tr><tr><td>Succeeded</td><td>Pod 中的所有容器都已经成功终止，并且不会再被重启</td></tr><tr><td>Failed</td><td>Pod 中的所有容器都已经终止，至少一个容器终止于失败状态：容器的进程退出码不是 0，或者被系统 kill</td></tr><tr><td>Unknown</td><td>因为某些未知原因，不能确定 Pod 的状态，通常的原因是 master 与 Pod 所在节点之间的通信故障</td></tr></tbody></table><h2 id="容器的检查"><a href="#容器的检查" class="headerlink" title="容器的检查"></a>容器的检查</h2><p>Probe 是指 kubelet 周期性地检查容器的状况。</p><p>有三种类型的 Probe：</p><ul><li><strong>ExecAction：</strong> 在容器内执行一个指定的命令。如果该命令的退出状态码为 0，则成功</li><li><strong>TCPSocketAction：</strong> 探测容器的指定 TCP 端口，如果该端口处于 open 状态，则成功</li><li><strong>HTTPGetAction：</strong> 探测容器指定端口/路径上的 HTTP Get 请求，如果 HTTP 响应状态码在 200 到 400（不包含400）之间，则成功</li></ul><p>Probe 有三种可能的结果：</p><ul><li><strong>Success：</strong> 容器通过检测</li><li><strong>Failure：</strong> 容器未通过检测</li><li><strong>Unknown：</strong> 检测执行失败，此时 kubelet 不做任何处理</li></ul><p>Kubelet 可以在两种情况下对运行中的容器执行 Probe：</p><ul><li><strong>就绪检查 readinessProbe：</strong> 确定容器是否已经就绪并接收服务请求。如果就绪检查失败，kubernetes 将该 Pod 的 IP 地址从所有匹配的 Service 的资源池中移除掉。</li><li><strong>健康检查 livenessProbe：</strong> 确定容器是否正在运行。如果健康检查失败，kubelete 将结束该容器，并根据 restart policy（重启策略）确定是否重启该容器。</li></ul><h3 id="何时使用-健康检查-就绪检查？"><a href="#何时使用-健康检查-就绪检查？" class="headerlink" title="何时使用 健康检查/就绪检查？"></a>何时使用 健康检查/就绪检查？</h3><ul><li>如果容器中的进程在碰到问题时可以自己 crash，并不需要执行健康检查；kubelet 可以自动的根据 Pod 的 restart policy（重启策略）执行对应的动作</li><li>如果希望在容器的进程无响应后，将容器 kill 掉并重启，则指定一个健康检查 liveness probe，并同时指定 restart policy（重启策略）为 Always 或者 OnFailure</li><li>如果想在探测 Pod 确实就绪之后才向其分发服务请求，请指定一个就绪检查 readiness probe。此时，就绪检查的内容可能和健康检查相同。就绪检查适合如下几类容器：<ul><li>初始化时需要加载大量的数据、配置文件</li><li>启动时需要执行迁移任务</li></ul></li></ul><h2 id="容器的状态"><a href="#容器的状态" class="headerlink" title="容器的状态"></a>容器的状态</h2><p>一旦 Pod 被调度到节点上，kubelet 便开始使用容器引擎（通常是 docker）创建容器。容器有三种可能的状态：Waiting / Running / Terminated：</p><ul><li><strong>Waiting：</strong> 容器的初始状态。处于 Waiting 状态的容器，仍然有对应的操作在执行，例如：拉取镜像、应用 Secrets等。</li><li><strong>Running：</strong> 容器处于正常运行的状态。容器进入 Running 状态之后，如果指定了 postStart hook，该钩子将被执行。</li><li><strong>Terminated：</strong> 容器处于结束运行的状态。容器进入 Terminated 状态之前，如果指定了 preStop hook，该钩子将被执行。</li></ul><h2 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h2><p>定义 Pod 或工作负载时，可以指定 restartPolicy，可选的值有：</p><ul><li>Always （默认值）</li><li>OnFailure</li><li>Never</li></ul><p>restartPolicy 将作用于 Pod 中的所有容器。kubelete 将在五分钟内，按照递延的时间间隔（10s, 20s, 40s ……）尝试重启已退出的容器，并在十分钟后再次启动这个循环，直到容器成功启动，或者 Pod 被删除。</p><h2 id="容器组的存活期"><a href="#容器组的存活期" class="headerlink" title="容器组的存活期"></a>容器组的存活期</h2><p>通常，如果没有人或者控制器删除 Pod，Pod 不会自己消失。</p><p>只有一种例外，那就是 Pod 处于 Scucceeded 或 Failed 的 phase，并超过了垃圾回收的时长（在 kubernetes master 中通过 terminated-pod-gc-threshold 参数指定），kubelet 自动将其删除。</p><h1 id="三、Pod-容器组-初始化容器"><a href="#三、Pod-容器组-初始化容器" class="headerlink" title="三、Pod 容器组_初始化容器"></a>三、Pod 容器组_初始化容器</h1><h2 id="初始化容器的行为"><a href="#初始化容器的行为" class="headerlink" title="初始化容器的行为"></a>初始化容器的行为</h2><ul><li>Pod 的启动时，首先初始化网络和数据卷，然后按顺序执行每一个初始化容器。任何一个初始化容器都必须成功退出，才能开始下一个初始化容器。如果某一个容器启动失败或者执行失败，kubelet 将根据 Pod 的 restartPolicy 决定是否重新启动 Pod。</li><li>只有所有的初始化容器全都执行成功，Pod 才能进入 ready 状态。初始化容器的端口是不能够通过 kubernetes Service 访问的。Pod 在初始化过程中处于 Pending 状态，并且同时有一个 type 为 <code>initializing</code> status 为 <code>True</code> 的 Condition</li><li>如果 Pod 重启，所有的初始化容器也将被重新执行。</li><li>可以组合使用就绪检查和 activeDeadlineSeconds ，以防止初始化容器始终失败。</li><li>Pod 中不能包含两个同名的容器（初始化容器和工作容器也不能同名）。</li></ul><h3 id="Pod-重启的原因"><a href="#Pod-重启的原因" class="headerlink" title="Pod 重启的原因"></a>Pod 重启的原因</h3><p>Pod 重启时，所有的初始化容器都会重新执行，Pod 重启的原因可能有：</p><ul><li>用户更新了 Pod 的定义，并改变了初始化容器的镜像<ul><li>改变任何一个初始化容器的镜像，将导致整个 Pod 重启</li><li>改变工作容器的镜像，将只重启该工作容器，而不重启 Pod</li></ul></li><li>Pod 容器基础设施被重启（例如 docker engine），这种情况不常见，通常只有 node 节点的 root 用户才可以执行此操作</li><li>Pod 中所有容器都已经结束，restartPolicy 是 Always，且初始化容器执行的记录已经被垃圾回收，此时将重启整个 Pod</li></ul><h2 id="配置初始化容器"><a href="#配置初始化容器" class="headerlink" title="配置初始化容器"></a>配置初始化容器</h2><p>Pod的配置文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">init-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="comment"># These containers are run during pod initialization</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wget</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"-O"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"/work-dir/index.html"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://kuboard.cn</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">"/work-dir"</span></span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">Default</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">    <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p> 从配置文件可以看出，Pod 中初始化容器和应用程序共享了同一个数据卷。初始化容器将该共享数据卷挂载到 <code>/work-dir</code> 路径，应用程序容器将共享数据卷挂载到 <code>/usr/share/nginx/html</code> 路径。初始化容器执行如下命令后，就退出执行： <code>wget -O /work-dir/index.html https://kuboard.cn</code></p><p>验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master k8s-yamls]# kubectl get pod init-demo</span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE</span><br><span class="line">init-demo   1&#x2F;1     Running   0          22s</span><br><span class="line">[root@k8s-master k8s-yamls]# kubectl exec -it init-demo -- &#x2F;bin&#x2F;bash</span><br><span class="line">root@init-demo:&#x2F;# apt-get update</span><br></pre></td></tr></table></figure><h1 id="四、Pod-容器组-Debug初始化容器"><a href="#四、Pod-容器组-Debug初始化容器" class="headerlink" title="四、Pod 容器组_Debug初始化容器"></a>四、Pod 容器组_Debug初始化容器</h1><p>查看 Pod 的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod &lt;pod-name&gt;</span><br><span class="line">NAME         READY     STATUS     RESTARTS   AGE</span><br><span class="line">&lt;pod-name&gt;   0/1       Init:1/2   0          7s</span><br><span class="line"></span><br><span class="line">例如，状态如果是 Init:1/2，则表明了两个初始化容器当中的一个已经成功执行：</span><br></pre></td></tr></table></figure><p>查看初始化容器的详情</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure><h2 id="理解-Pod-状态"><a href="#理解-Pod-状态" class="headerlink" title="理解 Pod 状态"></a>理解 Pod 状态</h2><p>如果 Pod 的状态以 <code>Init:</code> 开头，表示该 Pod 正在执行初始化容器。下表描述了 Debug 初始化容器的过程中，一些可能出现的 Pod 状态：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td><code>Init:N/M</code></td><td>Pod 中包含 M 个初始化容器，其中 N 个初始化容器已经成功执行</td></tr><tr><td><code>Init:Error</code></td><td>Pod 中有一个初始化容器执行失败</td></tr><tr><td><code>Init:CrashLoopBackOff</code></td><td>Pod 中有一个初始化容器反复执行失败</td></tr><tr><td><code>Pending</code></td><td>Pod 还未开始执行初始化容器</td></tr><tr><td><code>PodInitializing</code> or <code>Running</code></td><td>Pod 已经完成初始化容器的执行</td></tr></tbody></table><h1 id="五、Pod-容器组-配置PodDisruptionBudget"><a href="#五、Pod-容器组-配置PodDisruptionBudget" class="headerlink" title="五、Pod 容器组_配置PodDisruptionBudget"></a>五、Pod 容器组_配置PodDisruptionBudget</h1><p>​    在Kubernetes中，为了保证业务不中断或业务SLA不降级，需要将应用进行集群化部署。通过PodDisruptionBudget控制器可以设置应用 Pod 集群处于运行状态最低个数，也可以设置应用Pod 集群处于运行状态的最低百分比，这样可以保证在主动销毁应用Pod的时候，不会一次性销毁太多的应用Pod，从而保证业务不中断或业务SLA不降级。</p><p>在Kubernetes 1.5中，kubectl drain命令已经支持了PodDisruptionBudget控制器，在进行kubectl drain操作时会根据PodDisruptionBudget控制器判断应用Pod集群数量，进而保证在业务不中断或业务SLA不降级的情况下进行应用Pod销毁。</p><h2 id="确定需要PDB保护的应用"><a href="#确定需要PDB保护的应用" class="headerlink" title="确定需要PDB保护的应用"></a>确定需要PDB保护的应用</h2><p>通常如下几种 Kubernetes 控制器创建的应用程序可以使用 PDB：</p><ul><li>Deployment</li><li>ReplicationController</li><li>ReplicaSet</li><li>StatefulSet</li></ul><p>PDB 中 <code>.spec.selector</code> 字段的内容必须与控制器中 <code>.spec.selector</code> 字段的内容相同。</p><h3 id="当毁坏发生时，在短时间内，应用程序最多可以容许多少个实例被终止？"><a href="#当毁坏发生时，在短时间内，应用程序最多可以容许多少个实例被终止？" class="headerlink" title="当毁坏发生时，在短时间内，应用程序最多可以容许多少个实例被终止？"></a>当毁坏发生时，在短时间内，应用程序最多可以容许多少个实例被终止？</h3><ul><li>无状态的前端：<ul><li>关注点：不能让服务能力（serving capacity）降低超过 10%</li><li>解决方案：在 PDB 中配置 minAvailable 90%</li></ul></li><li>单实例有状态应用：<ul><li>关注点：未经同意不能关闭此应用程序</li><li>解决方案1： 不使用 PDB，并且容忍偶尔的停机</li><li>解决方案2： 在 PDB 中设置 maxUnavailable=0。与集群管理员达成一致（不是通过Kubernetes，而是邮件、电话或面对面），请集群管理员在终止应用之前与你沟通。当集群管理员联系你时，准备好停机时间，删除 PDB 以表示已准备好应对毁坏。并做后续处理</li></ul></li><li>多实例有状态应用，例如 consul、zookeeper、etcd：<ul><li>关注点：不能将实例数降低到某个数值，否则写入会失败</li><li>解决方案1： 在 PDB 中设置 maxUnavailable 为 1 （如果副本数会发生变化，可以使用此设置）</li><li>解决方案2： 在 PDB 中设置 minAvailable 为最低数量（例如，当总副本数为 5 时，设置为3）（可以同时容忍更多的毁坏数）</li></ul></li><li>可以重新开始的批处理任务：<ul><li>关注点：当发生自愿毁坏时，Job仍然需要完成其执行任务</li><li>解决方案： 不创建 PDB。Job 控制器将会创建一个 Pod 用于替换被毁坏的 Pod</li></ul></li></ul><h3 id="指定百分比时的舍入逻辑"><a href="#指定百分比时的舍入逻辑" class="headerlink" title="指定百分比时的舍入逻辑"></a>指定百分比时的舍入逻辑</h3><p><code>minAvailable</code> 或 <code>maxUnavailable</code> 可以指定为整数或者百分比。</p><ul><li>当指定一个整数时，代表 Pod 的数量。例如，设置 <code>minAvailable</code> 为 10，则至少 10 个 Pod 必须始终可用，即便是在毁坏发生时</li><li>当指定一个百分比时（例如，<code>50%</code>），代表总 Pod 数量的一个百分比。例如，设置 <code>maxUnavailable</code> 为 <code>50%</code>，则最多可以有 50% 的 Pod 可以被毁坏</li></ul><p>如果指定这些值为一个百分数，其计算结果可能不会正好是一个整数。例如，假设有 7 个 Pod，<code>minAvailable</code> 设置为 <code>50%</code>，你将很难判断，到底是 3 个还是 4 个 Pod 必须始终保持可用。Kubernetes 将向上舍入（round up to the nearest integer），因此，此处必须有 4 个 Pod 始终可用。</p><h3 id="定义PodDisruptionBudget"><a href="#定义PodDisruptionBudget" class="headerlink" title="定义PodDisruptionBudget"></a>定义PodDisruptionBudget</h3><p><code>PodDisruptionBudget</code> 包含三个字段：</p><ul><li>标签选择器 <code>.spec.selector</code> 用于指定 PDB 适用的 Pod。此字段为必填</li><li><code>.spec.minAvailable</code>：当完成驱逐时，最少仍然要保留多少个 Pod 可用。该字段可以是一个整数，也可以是一个百分比</li><li><code>.spec.maxUnavailable</code>： 当完成驱逐时，最多可以有多少个 Pod 被终止。该字段可以是一个整数，也可以是一个百分比</li></ul><p>在一个 <code>PodDisruptionBudget</code> 中，只能指定 <code>maxUnavailable</code> 和 <code>minAvailable</code> 中的一个。 <code>maxUnavailable</code> 只能应用到那些有控制器的 Pod 上。下面的例子中，“期望的副本数” 是 PodDisruptionBudget 对应 Pod 的控制器的 <code>.spec.replicas</code> 字段：</p><p>例子1： <code>minAvailable</code> 为 5 时，只要 PodDisruptionBudget 的 <code>selector</code> 匹配的 Pod 中有超过 5 个仍然可用，就可以继续驱逐 Pod </p><p>例子2： <code>minAvailable</code> 为 30% 时，至少保证期望副本数的 30% 可用 </p><p>例子3： <code>maxUnavailable</code> 为 5 时，最多可以有 5 个副本不可用（unthealthy）</p><p>例子4： <code>maxUnavailable</code> 为 30% 时，最多可以有期望副本数的 30% 不可用</p><p>通常，一个 PDB 对应一个控制器创建的 Pod，例如，Deployment、ReplicaSet或StatefulSet。</p><h3 id="使用-minAvailable"><a href="#使用-minAvailable" class="headerlink" title="使用 minAvailable"></a>使用 minAvailable</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodDisruptionBudget</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zk-pdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minAvailable:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">zookeeper</span></span><br><span class="line">      </span><br><span class="line"><span class="string">[root@k8s-master</span> <span class="string">k8s-yamls]#</span> <span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span>  <span class="string">zk-pdb.yaml</span> </span><br><span class="line"><span class="string">poddisruptionbudget.policy/zk-pdb</span> <span class="string">created</span></span><br><span class="line"></span><br><span class="line"><span class="string">[root@k8s-master</span> <span class="string">k8s-yamls]#</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">poddisruptionbudgets</span></span><br><span class="line"><span class="string">NAME</span>     <span class="string">MIN</span> <span class="string">AVAILABLE</span>   <span class="string">MAX</span> <span class="string">UNAVAILABLE</span>   <span class="string">ALLOWED</span> <span class="string">DISRUPTIONS</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">zk-pdb</span>   <span class="number">2</span>               <span class="string">N/A</span>               <span class="number">0</span>                     <span class="string">26s</span></span><br></pre></td></tr></table></figure><h3 id="使用-maxUnavailable"><a href="#使用-maxUnavailable" class="headerlink" title="使用 maxUnavailable"></a>使用 maxUnavailable</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodDisruptionBudget</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zk-pdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">maxUnavailable:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">zookeeper</span></span><br><span class="line">      </span><br><span class="line"><span class="string">[root@k8s-master</span> <span class="string">k8s-yamls]#</span> <span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">max_zk-pdb.yaml</span> </span><br><span class="line"><span class="string">poddisruptionbudget.policy/zk-pdb</span> <span class="string">configured</span></span><br><span class="line"></span><br><span class="line"><span class="string">[root@k8s-master</span> <span class="string">k8s-yamls]#</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">poddisruptionbudgets</span></span><br><span class="line"><span class="string">NAME</span>     <span class="string">MIN</span> <span class="string">AVAILABLE</span>   <span class="string">MAX</span> <span class="string">UNAVAILABLE</span>   <span class="string">ALLOWED</span> <span class="string">DISRUPTIONS</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">zk-pdb</span>   <span class="string">N/A</span>             <span class="number">1</span>                 <span class="number">0</span>                     <span class="string">98s</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pod的相关理解&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title> Kubernetes容器</title>
    <link href="http://yoursite.com/2020/03/28/Kubernetes%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2020/03/28/Kubernetes%E5%AE%B9%E5%99%A8/</id>
    <published>2020-03-28T06:58:54.000Z</published>
    <updated>2020-03-28T07:35:24.859Z</updated>
    
    <content type="html"><![CDATA[<p> Kubernetes中容器的相关</p><a id="more"></a> <h1 id="一、容器"><a href="#一、容器" class="headerlink" title="一、容器"></a>一、容器</h1><h2 id="容器镜像"><a href="#容器镜像" class="headerlink" title="容器镜像"></a>容器镜像</h2><p>在 Kubernetes 的 Pod 中使用容器镜像之前，您必须将其推送到一个镜像仓库（或者使用仓库中已经有的容器镜像）。在 Kubernetes 的 Pod 定义中定义容器时，必须指定容器所使用的镜像，容器中的 <code>image</code> 字段支持与 <code>docker</code> 命令一样的语法，包括私有镜像仓库和标签。</p><p>例如：<code>my-registry.example.com:5000/example/web-example:v1.0.1</code> 由如下几个部分组成：</p><p>my-registry.example.com:5000/example/web-example:v1.0.1</p><ul><li>my-registry.example.com：registry 地址</li><li>:5000：registry 端口</li><li>example：repository 名字</li><li>web-example：image 名字</li><li>v1.0.1：image 标签</li></ul><p>如果使用 <code>hub.dokcer.com</code> Registry 中的镜像，可以省略 registry 地址和 registry 端口。</p><p>例如：<code>nginx:latest</code>，<code>eipwork/kuboard</code></p><h3 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h3><p>Kubernetes中，默认的镜像抓取策略是 <code>IfNotPresent</code>，使用此策略，kubelet在发现本机有镜像的情况下，不会向镜像仓库抓取镜像。如果想每次启动 Pod 时，都强制从镜像仓库抓取镜像，可以尝试如下方式：</p><ul><li>设置 container 中的 <code>imagePullPolicy</code> 为 <code>Always</code></li><li>省略 <code>imagePullPolicy</code> 字段，并使用 <code>:latest</code> tag 的镜像</li><li>省略 <code>imagePullPolicy</code> 字段和镜像的 tag</li><li>激活 AlwaysPullImages 管理控制器</li></ul><p>imagePullPolicy 字段和 image tag的可能取值将影响到 kubelet 如何抓取镜像：</p><ul><li><code>imagePullPolicy: IfNotPresent</code> 仅在节点上没有该镜像时，从镜像仓库抓取</li><li><code>imagePullPolicy: Always</code> 每次启动 Pod 时，从镜像仓库抓取</li><li><code>imagePullPolicy</code> 未填写，镜像 tag 为 <code>:latest</code> 或者未填写，则同 <code>Always</code> 每次启动 Pod 时，从镜像仓库抓取</li><li><code>imagePullPolicy</code> 未填写，镜像 tag 已填写但不是 <code>:latest</code>，则同 <code>IfNotPresent</code> 仅在节点上没有该镜像时，从镜像仓库抓取</li><li><code>imagePullPolicy: Never</code>，Kubernetes 假设本地存在该镜像，并且不会尝试从镜像仓库抓取镜像</li></ul><h1 id="二、容器的环境变量"><a href="#二、容器的环境变量" class="headerlink" title="二、容器的环境变量"></a>二、容器的环境变量</h1><p>Kubernetes为容器提供了一系列重要的资源：</p><ul><li>由镜像、一个或多个数据卷合并组成的文件系统</li><li>容器自身的信息</li><li>集群中其他重要对象的信息</li></ul><h2 id="集群的信息"><a href="#集群的信息" class="headerlink" title="集群的信息"></a>集群的信息</h2><p>在容器创建时，集群中所有的 Service 的连接信息将以环境变量的形式注入到容器中。例如，已创建了一个名为 <code>Foo</code> 的 Service，此时再创建任何容器时，该容器将包含如下环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FOO_SERVICE_HOST &#x3D; &lt;Service的ClusterIP&gt;</span><br><span class="line">FOO_SERVICE_PORT &#x3D; &lt;Service的端口&gt;</span><br></pre></td></tr></table></figure><h1 id="三、容器生命周期"><a href="#三、容器生命周期" class="headerlink" title="三、容器生命周期"></a>三、容器生命周期</h1><h2 id="容器钩子"><a href="#容器钩子" class="headerlink" title="容器钩子"></a>容器钩子</h2><p>Kubernetes中为容器提供了两个 hook（钩子函数）：</p><ul><li><p><code>PostStart</code></p><p>此钩子函数在容器创建后将立刻执行。但是，并不能保证该钩子函数在容器的 <code>ENTRYPOINT</code> 之前执行。该钩子函数没有输入参数。</p></li><li><p><code>PreStop</code></p><p>此钩子函数在容器被 terminate（终止）之前执行，例如：</p><ul><li>通过接口调用删除容器所在 Pod</li><li>某些管理事件的发生：健康检查失败、资源紧缺等</li></ul><p>如果容器已经被关闭或者进入了 <code>completed</code> 状态，preStop 钩子函数的调用将失败。该函数的执行是同步的，即，kubernetes 将在该函数完成执行之后才删除容器。该钩子函数没有输入参数。</p><h3 id="Hook-handler的实现"><a href="#Hook-handler的实现" class="headerlink" title="Hook handler的实现"></a>Hook handler的实现</h3><p>容器只要实现并注册 hook handler 便可以使用钩子函数。Kubernetes 中，容器可以实现两种类型的 hook handler：</p><ul><li>Exec - 在容器的名称空进和 cgroups 中执行一个指定的命令，例如 <code>pre-stop.sh</code>。该命令所消耗的 CPU、内存等资源，将计入容器可以使用的资源限制。</li><li>HTTP - 向容器的指定端口发送一个 HTTP 请求</li></ul><h3 id="Hook-handler的执行"><a href="#Hook-handler的执行" class="headerlink" title="Hook handler的执行"></a>Hook handler的执行</h3><p>当容器的生命周期事件发生时，Kubernetes 在容器中执行该钩子函数注册的 handler。</p><p>对于 Pod 而言，hook handler 的调用是同步的。即，如果是 <code>PostStart</code> hook，容器的 <code>ENTRYPOINT</code> 和 hook 是同时出发的，然而如果 hook 执行的时间过长或者挂起了，容器将不能进入到 <code>Running</code> 状态。</p><p><code>PreStop</code> hook 的行为与此相似。如果 hook 在执行过程中挂起了，Pod phase 将停留在 <code>Terminating</code> 的状态，并且在 <code>terminationGracePeriodSeconds</code> 超时之后，Pod被删除。如果 <code>PostStart</code> 或者 <code>PreStop</code> hook 执行失败，则 Kubernetes 将 kill（杀掉）该容器。</p><p>用户应该使其 hook handler 越轻量级越好。例如，对于长时间运行的任务，在停止容器前，调用 <code>PreStop</code> 钩子函数，以保存当时的计算状态和数据。</p><h3 id="Hook触发的保证"><a href="#Hook触发的保证" class="headerlink" title="Hook触发的保证"></a>Hook触发的保证</h3><p>Hook 将至少被触发一次，即，当指定事件 <code>PostStart</code> 或 <code>PreStop</code> 发生时，hook 有可能被多次触发。hook handler 的实现需要保证即使多次触发，执行也不会出错。</p><p>通常来说，hook 实际值被触发一次。例如：如果 HTTP hook 的服务端已经停机，或者因为网络的问题不能接收到请求，请求将不会被再次发送。在极少数的情况下， 触发两次 hook 的事情会发生。例如，如果 kueblet 在触发 hook 的过程中重启了，该 hook 将在 Kubelet 重启后被再次触发。</p><h3 id="调试-hook-handler"><a href="#调试-hook-handler" class="headerlink" title="调试 hook handler"></a>调试 hook handler</h3><p>Hook handler 的日志并没有在 Pod 的 events 中发布。如果 handler 因为某些原因失败了，kubernetes 将广播一个事件 <code>PostStart</code> hook 发送 <code>FailedPreStopHook</code> 事件。 可以执行命令 <code>kubectl describe pod $(pod_name)</code> 以查看这些事件。</p></li></ul><h1 id="四、容器生命周期事件处理"><a href="#四、容器生命周期事件处理" class="headerlink" title="四、容器生命周期事件处理"></a>四、容器生命周期事件处理</h1><p>Kubernetes 中支持容器的 postStart 和 preStop 事件，本文阐述了如何向容器添加生命周期事件处理程序（handler）。</p><ul><li><code>postStart</code> 容器启动时，Kubernetes 立刻发送 postStart 事件，但不确保对应的 handler 是否能在容器的 <code>EntryPoint</code> 之前执行</li><li><code>preStop</code> 容器停止前，Kubernetes 发送 preStop 事件</li></ul><h2 id="定义postStart和preStop处理程序"><a href="#定义postStart和preStop处理程序" class="headerlink" title="定义postStart和preStop处理程序"></a>定义postStart和preStop处理程序</h2><p>创建一个包含单一容器的 Pod，并为该容器关联 postStart 和 preStop 处理程序（handler）。Pod 的yaml文件定义如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lifecycle-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lifecycle-demo-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">["/bin/sh",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"echo Hello from the postStart handler &gt; /usr/share/message"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">["/bin/sh","-c","nginx</span> <span class="string">-s</span> <span class="string">quit;</span> <span class="string">while</span> <span class="string">killall</span> <span class="number">-0</span> <span class="string">nginx;</span> <span class="string">do</span> <span class="string">sleep</span> <span class="number">1</span><span class="string">;</span> <span class="string">done"]</span></span><br></pre></td></tr></table></figure><p>在该例子中，请注意：</p><ul><li>postStart 命令向 <code>usr/share/message</code> 文件写入了一行文字</li><li>preStop 命令优雅地关闭了 nginx</li></ul><blockquote><p>如果容器碰到问题，被 Kubernetes 关闭，这个操作是非常有帮助的，可以使得您的程序在关闭前执行必要的清理任务</p></blockquote><ul><li>创建pod</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl apply -f lifecycle-demo.yaml </span></span><br><span class="line">pod/lifecycle-demo created</span><br><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl get pod -A</span></span><br><span class="line">NAMESPACE     NAME                                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">default       lifecycle-demo                                1/1     Running   0          50s</span><br></pre></td></tr></table></figure><ul><li>进入容器的命令行终端： </li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl exec -it lifecycle-demo -- /bin/bash</span></span><br><span class="line">root@lifecycle-demo:/<span class="comment"># cat /usr/share/message</span></span><br><span class="line">Hello from the postStart handler</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kubernetes 在容器启动后立刻发送 postStart 事件，但是并不能确保 postStart 事件处理程序在容器的 EntryPoint 之前执行。</p><p>postStart 事件处理程序相对于容器中的进程来说是异步的（同时执行），然而，Kubernetes 在管理容器时，将一直等到 postStart 事件处理程序结束之后，才会将容器的状态标记为 Running。</p><p>Kubernetes 在决定关闭容器时，立刻发送 preStop 事件，并且，将一直等到 preStop 事件处理程序结束或者 Pod 的 <code>--grace-period</code> 超时，才删除容器。</p><p>注意： Kubernetes 只在 Pod <code>Teminated</code> 状态时才发送 preStop 事件，这意味着，如果 Pod 已经进入了 <code>Completed</code> 状态， preStop 事件处理程序将不会被调用 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; Kubernetes中容器的相关&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>k8s标签和选择器</title>
    <link href="http://yoursite.com/2020/03/28/k8s%E6%A0%87%E7%AD%BE%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://yoursite.com/2020/03/28/k8s%E6%A0%87%E7%AD%BE%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/</id>
    <published>2020-03-28T06:26:59.000Z</published>
    <updated>2020-03-28T06:56:51.605Z</updated>
    
    <content type="html"><![CDATA[<p>标签和标签选择器的作用</p> <a id="more"></a> <h1 id="标签和选择器"><a href="#标签和选择器" class="headerlink" title="标签和选择器"></a>标签和选择器</h1><p>标签（Label）是附加在Kubernetes对象上的一组名值对，其意图是按照对用户有意义的方式来标识Kubernetes对象，同时，又不对Kubernetes的核心逻辑产生影响。</p><p>标签可以用来组织和选择一组Kubernetes对象。</p><p>可以在创建Kubernetes对象时为其添加标签，也可以在创建以后再为其添加标签。</p><p>使用标签（Label）可以高效地查询和监听Kubernetes对象 </p><p>每个Kubernetes对象可以有多个标签，同一个对象的标签的 Key 必须唯一，例如： </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">key1:</span> <span class="string">value1</span></span><br><span class="line">    <span class="attr">key2:</span> <span class="string">value2</span></span><br></pre></td></tr></table></figure><h2 id="为什么要使用标签"><a href="#为什么要使用标签" class="headerlink" title="为什么要使用标签"></a>为什么要使用标签</h2><p>使用标签，用户可以按照自己期望的形式组织 Kubernetes 对象之间的结构，而无需对 Kubernetes 有任何修改。</p><p>应用程序的部署或者批处理程序的部署通常都是多维度的（例如，多个高可用分区、多个程序版本、多个微服务分层）。管理这些对象时，很多时候要针对某一个维度的条件做整体操作，例如，将某个版本的程序整体删除，这种情况下，如果用户能够事先规划好标签的使用，再通过标签进行选择，就会非常地便捷。</p><p>标签的例子有：</p><ul><li><code>release: stable</code>、<code>release: canary</code></li><li><code>environment: dev</code>、<code>environment: qa</code>、<code>environment: production</code></li><li><code>tier: frontend</code>、<code>tier: backend</code>、<code>tier: cache</code></li><li><code>partition: customerA</code>、<code>partition: customerB</code></li><li><code>track: daily</code>、<code>track: weekly</code></li></ul><p>上面只是一些使用比较普遍的标签，可以根据您自己的情况建立合适的使用标签</p><h2 id="句法和字符集"><a href="#句法和字符集" class="headerlink" title="句法和字符集"></a>句法和字符集</h2><p> 标签是一组名值对（key/value pair）。标签的 key 可以有两个部分：可选的前缀和标签名，通过 <code>/</code> 分隔。 </p><p> 例如，下面的例子中的Pod包含两个标签 <code>environment: production</code> 和 <code>app:nginx</code> </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">label-demo</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">production</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h2 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h2><p>与 name 和 UID 不同，标签不一定是唯一的。通常来讲，会有多个Kubernetes对象包含相同的标签。通过使用标签选择器（label selector），用户/客户端可以选择一组对象。标签选择器（label selector）是 Kubernetes 中最主要的分类和筛选手段。</p><p>Kubernetes api server支持两种形式的标签选择器，<code>equality-based 基于等式的</code> 和 <code>set-based 基于集合的</code>。标签选择器可以包含多个条件，并使用逗号分隔，此时只有满足所有条件的 Kubernetes 对象才会被选中。</p><p>如果使用空的标签选择器或者不指定选择器，其含义由具体的 API 接口决定。</p><h3 id="基于等式的选择方式"><a href="#基于等式的选择方式" class="headerlink" title="基于等式的选择方式"></a>基于等式的选择方式</h3><p> Equality- 或者 inequality-based 选择器可以使用标签的名和值来执行过滤选择。只有匹配所有条件的对象才被选中（被选中的对象可以包含未指定的标签）。可以使用三种操作符 <code>=</code>、<code>==</code>、<code>!=</code>。前两个操作符含义是一样的，都代表相等，后一个操作符代表不相等。例如： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择了标签名为 `environment` 且 标签值为 `production` 的Kubernetes对象</span></span><br><span class="line">environment = production</span><br><span class="line"><span class="comment"># 选择了标签名为 `tier` 且标签值不等于 `frontend` 的对象，以及不包含标签 `tier` 的对象</span></span><br><span class="line">tier != frontend</span><br></pre></td></tr></table></figure><p>也可以使用逗号分隔的两个等式 <code>environment=production,tier!=frontend</code>，此时将选中所有 <code>environment</code> 为 <code>production</code> 且 <code>tier</code> 不为 <code>frontend</code> 的对象。</p><p>以Pod 的节点选择器为例，下面的 Pod 可以被调度到包含标签 <code>accelerator=nvidia-tesla-p100</code> 的节点上：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cuda-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cuda-test</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">"k8s.gcr.io/cuda-vector-add:v0.1"</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">nvidia.com/gpu:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">accelerator:</span> <span class="string">nvidia-tesla-p100</span></span><br></pre></td></tr></table></figure><h3 id="基于集合的选择方式"><a href="#基于集合的选择方式" class="headerlink" title="基于集合的选择方式"></a>基于集合的选择方式</h3><p> Set-based 标签选择器可以根据标签名的一组值进行筛选。支持的操作符有三种：<code>in</code>、<code>notin</code>、<code>exists</code>。例如： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择所有的包含 `environment` 标签且值为 `production` 或 `qa` 的对象</span></span><br><span class="line">environment <span class="keyword">in</span> (production, qa)</span><br><span class="line"><span class="comment"># 选择所有的 `tier` 标签不为 `frontend` 和 `backend`的对象，或不含 `tier` 标签的对象</span></span><br><span class="line">tier notin (frontend, backend)</span><br><span class="line"><span class="comment"># 选择所有包含 `partition` 标签的对象</span></span><br><span class="line">partition</span><br><span class="line"><span class="comment"># 选择所有不包含 `partition` 标签的对象</span></span><br><span class="line">!partition</span><br></pre></td></tr></table></figure><p> 可以组合多个选择器，用 <code>,</code> 分隔，<code>,</code> 相当于 <code>AND</code> 操作符。例如： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择包含 `partition` 标签（不检查标签值）且 `environment` 不是 `qa` 的对象</span></span><br><span class="line">partition,environment notin (qa)</span><br></pre></td></tr></table></figure><p>基于集合的选择方式是一个更宽泛的基于等式的选择方式，例如，<code>environment=production</code> 等价于 <code>environment in (production)</code>；<code>environment!=production</code> 等价于 <code>environment notin (production)</code>。</p><p>基于集合的选择方式可以和基于等式的选择方式可以混合使用，例如： <code>partition in (customerA, customerB),environment!=qa</code></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h3><p>LIST 和 WATCH 操作时，可指定标签选择器作为查询条件，以筛选指定的对象集合。两种选择方式都可以使用，但是要符合 URL 编码，例如：</p><ul><li>基于等式的选择方式： <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li>基于集合的选择方式： <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>两种选择方式都可以在 kubectl 的 list 和 watch 命令中使用，例如：</p><ul><li>使用基于等式的选择方式</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -l environment=production,tier=frontend</span><br></pre></td></tr></table></figure><ul><li>使用基于集合的选择方式</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -l <span class="string">'environment in (production),tier in (frontend)'</span></span><br></pre></td></tr></table></figure><h3 id="Kubernetes对象引用"><a href="#Kubernetes对象引用" class="headerlink" title="Kubernetes对象引用"></a>Kubernetes对象引用</h3><p>某些 Kubernetes 对象中（例如，Service和Deployment），使用标签选择器指定一组其他类型的 Kubernetes 对象（例如，Pod）</p><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>Service 中通过 <code>spec.selector</code> 字段来选择一组 Pod，并将服务请求转发到选中的 Pod 上。</p><p>在 yaml 或 json 文件中，标签选择器用一个 map 来定义，且支持基于等式的选择方式，例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"selector": &#123;</span><br><span class="line">  "component" : "redis",</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">selector:</span><br><span class="line">  component: redis</span><br></pre></td></tr></table></figure><p>上面的例子中定义的标签选择器等价于 <code>component=redis</code> 或 <code>component in (redis)</code></p><h4 id="有些对象支持基于集合的选择方式"><a href="#有些对象支持基于集合的选择方式" class="headerlink" title="有些对象支持基于集合的选择方式"></a>有些对象支持基于集合的选择方式</h4><p><code>Job</code>、<code>Deployment</code>、<code>ReplicaSet</code> 和 <code>DaemonSet</code> 同时支持基于等式的选择方式和基于集合的选择方式。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line">  <span class="attr">matchLabels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">matchExpressions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#123;key:</span> <span class="string">tier,</span> <span class="attr">operator:</span> <span class="string">In,</span> <span class="attr">values:</span> <span class="string">[cache]&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#123;key:</span> <span class="string">environment,</span> <span class="attr">operator:</span> <span class="string">NotIn,</span> <span class="attr">values:</span> <span class="string">[dev]&#125;</span></span><br></pre></td></tr></table></figure><p> <code>matchLabels</code> 是一个 {key,value} 组成的 map。map 中的一个 {key,value} 条目相当于 <code>matchExpressions</code> 中的一个元素，其 <code>key</code> 为 map 的 key，<code>operator</code> 为 <code>In</code>， <code>values</code> 数组则只包含 <code>value</code> 一个元素。<code>matchExpression</code> 等价于基于集合的选择方式，支持的 <code>operator</code> 有 <code>In</code>、<code>NotIn</code>、<code>Exists</code> 和 <code>DoesNotExist</code>。当 <code>operator</code> 为 <code>In</code> 或 <code>NotIn</code> 时，<code>values</code> 数组不能为空。所有的选择条件都以 AND 的形式合并计算，即所有的条件都满足才可以算是匹配 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标签和标签选择器的作用&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>使用名称空间共享集群</title>
    <link href="http://yoursite.com/2020/03/28/%E4%BD%BF%E7%94%A8%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E5%85%B1%E4%BA%AB%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2020/03/28/%E4%BD%BF%E7%94%A8%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E5%85%B1%E4%BA%AB%E9%9B%86%E7%BE%A4/</id>
    <published>2020-03-28T05:42:22.000Z</published>
    <updated>2020-03-28T06:23:37.173Z</updated>
    
    <content type="html"><![CDATA[<p>查看、创建、删除、使用namespace</p><a id="more"></a> <h1 id="使用名称空间共享集群"><a href="#使用名称空间共享集群" class="headerlink" title="使用名称空间共享集群"></a>使用名称空间共享集群</h1><h2 id="一、查看名称空间"><a href="#一、查看名称空间" class="headerlink" title="一、查看名称空间"></a>一、查看名称空间</h2><p>查看集群中的名称空间列表：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl get namespaces</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   23h</span><br><span class="line">kube-node-lease   Active   23h</span><br><span class="line">kube-public       Active   23h</span><br><span class="line">kube-system       Active   23h</span><br></pre></td></tr></table></figure><p>Kubernetes 安装成功后，默认有初始化了三个名称空间：</p><ul><li><strong>default</strong> 默认名称空间，如果 Kubernetes 对象中不定义 <code>metadata.namespace</code> 字段，该对象将放在此名称空间下</li><li><strong>kube-system</strong> Kubernetes系统创建的对象放在此名称空间下</li><li><strong>kube-public</strong> 此名称空间自动在安装集群是自动创建，并且所有用户都是可以读取的（即使是那些未登录的用户）。主要是为集群预留的，例如，某些情况下，某些Kubernetes对象应该被所有集群用户看到。</li></ul><p>查看名称空间详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl describe namespaces kube-system</span></span><br><span class="line">Name:         kube-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Active</span><br><span class="line"></span><br><span class="line">No resource quota.</span><br><span class="line"></span><br><span class="line">No resource limits.</span><br></pre></td></tr></table></figure><ul><li>Resource quota 汇总了名称空间中使用的资源总量，并指定了集群管理员定义该名称空间最多可以使用的资源量</li><li>Limit range 定义了名称空间中某种具体的资源类型的最大、最小值</li></ul><p>名称空间可能有两种状态（phase）：</p><ul><li><strong>Active</strong> 名称空间正在使用中</li><li><strong>Termining</strong> 名称空间正在被删除，不能再向其中创建新的对象</li></ul><h2 id="二、创建名称空间"><a href="#二、创建名称空间" class="headerlink" title="二、创建名称空间"></a>二、创建名称空间</h2><p>使用kubectl有两种方式创建名称空间</p><p>1.通过 yaml 文件，创建文件 <code>my-namespace.yaml</code> </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;名称空间的名字&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行命令</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">./my-namespace.yaml</span></span><br></pre></td></tr></table></figure><ol start="2"><li>直接使用命令创建名称空间： </li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace &lt;名称空间的名字&gt;</span><br></pre></td></tr></table></figure><p>注意： 名称空间可以定义一个可选项字段 <code>finalizers</code>，在名称空间被删除时，用来清理相关的资源。 </p><p> 如果定义了一个不存在的 <code>finalizer</code>，仍然可以成功创建名称空间，但是当删除该名称空间时，将卡在 <code>Terminating</code> 状态。 </p><h2 id="三、删除名称空间"><a href="#三、删除名称空间" class="headerlink" title="三、删除名称空间"></a>三、删除名称空间</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete namespaces &lt;名称空间的名字&gt;</span><br></pre></td></tr></table></figure><p>注意：</p><p>该操作将删除名称空间中的所有内容（ 此删除操作是异步的，名称空间会停留在 <code>Terminating</code> 状态一段时间。 ）</p><h2 id="四、使用名称空间切分集群"><a href="#四、使用名称空间切分集群" class="headerlink" title="四、使用名称空间切分集群"></a>四、使用名称空间切分集群</h2><h3 id="理解-default-名称空间"><a href="#理解-default-名称空间" class="headerlink" title="理解 default 名称空间"></a>理解 <code>default</code> 名称空间</h3><p>默认情况下，安装Kubernetes集群时，会初始化一个 <code>default</code> 名称空间，用来将承载那些未指定名称空间的 Pod、Service、Deployment等对象</p><h3 id="创建新的名称空间"><a href="#创建新的名称空间" class="headerlink" title="创建新的名称空间"></a>创建新的名称空间</h3><p>假设企业使用同一个集群作为开发环境和生产环境（注意：通常开发环境和生产环境是物理隔绝的）：</p><ul><li><p>开发团队期望有一个集群中的空间，以便他们可以查看查看和使用他们创建的 Pod、Service、Deployment等。在此空间中，Kubernetes对象被创建又被删除，为了适应敏捷开发的过程，团队中的许多人都可以在此空间内做他们想做的事情。</p></li><li><p>运维团队也期望有一个集群中的空间，在这里，将有严格的流程控制谁可以操作 Pod、Service、Deployment等对象，因为这些对象都直接服务于生产环境。</p><p>此时，可以将一个Kubernetes集群切分成两个名称空间：<code>development</code> 和 <code>production</code>。创建名称空间的 yaml 文件如下所示：</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">development</span></span><br></pre></td></tr></table></figure><p> 执行命令以创建 <code>development</code> 名称空间： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl create -f dev.yaml </span></span><br><span class="line">namespace/development created</span><br><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl get namespaces --show-labels</span></span><br><span class="line">NAME              STATUS   AGE     LABELS</span><br><span class="line">default           Active   23h     &lt;none&gt;</span><br><span class="line">development       Active   2m10s   name=development</span><br><span class="line">kube-node-lease   Active   23h     &lt;none&gt;</span><br><span class="line">kube-public       Active   23h     &lt;none&gt;</span><br><span class="line">kube-system       Active   23h     &lt;none&gt;</span><br><span class="line">production        Active   67s     name=production</span><br></pre></td></tr></table></figure><h3 id="在每个名称空间中创建-Pod"><a href="#在每个名称空间中创建-Pod" class="headerlink" title="在每个名称空间中创建 Pod"></a>在每个名称空间中创建 Pod</h3><p>Kubernetes名称空间为集群中的 Pod、Service、Deployment 提供了一个作用域。可以限定使用某个名称空间的用户不能看到另外一个名称空间中的内容。我们可以在 <code>development</code> 名称空间中创建一个简单的 Deployment 和 Pod 来演示这个特性。</p><p>1.执行命令以检查当前的 kubectl 上下文</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl config view</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority-data: DATA+OMITTED</span><br><span class="line">    server: https://192.168.154.144:6443</span><br><span class="line">  name: kubernetes</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">    user: kubernetes-admin</span><br><span class="line">  name: kubernetes-admin@kubernetes</span><br><span class="line">current-context: kubernetes-admin@kubernetes</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: kubernetes-admin</span><br><span class="line">  user:</span><br><span class="line">    client-certificate-data: REDACTED</span><br><span class="line">    client-key-data: REDACTED</span><br></pre></td></tr></table></figure><p>2.执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl config current-context</span></span><br><span class="line">kubernetes-admin@kubernetes</span><br></pre></td></tr></table></figure><p>3.接下来，为 kubectl 定义一个上下文，以便在不同的名称空间中工作。<code>cluster</code> 和 <code>user</code> 字段的取值从前面的 current context 复制过来： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl config set-context dev --namespace=development --cluster=kubernetes-admin@kubernetes --user=kubernetes-admin@kubernetes</span></span><br><span class="line">Context <span class="string">"dev"</span> created.</span><br><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl config set-context prod --namespace=production --cluster=kubernetes-admin@kubernetes --user=kubernetes-admin@kubernetes</span></span><br><span class="line">Context <span class="string">"prod"</span> created.</span><br></pre></td></tr></table></figure><p> 上面的命令创建了两个 kubectl 的上下文，可以在两个不同的名称空间中工作： </p><ol start="4"><li>切换到 <code>development</code> 名称空间： </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl config use-context dev</span></span><br><span class="line">Switched to context <span class="string">"dev"</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">#验证</span></span><br><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl config current-context</span></span><br><span class="line">dev</span><br></pre></td></tr></table></figure><p> 此时，通过 kubectl 向 Kubernetes 集群发出的所有指令都限定在名称空间 <code>development</code> 里 </p><h4 id="在不同的namespace里工作"><a href="#在不同的namespace里工作" class="headerlink" title="在不同的namespace里工作"></a>在不同的namespace里工作</h4><p>创建一个 nginx</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kubectl run snowflake --image=nginx:1.7.9 --replicas=2</span><br><span class="line"></span><br><span class="line"><span class="comment">#刚刚创建的 Deployment 副本数为 2，运行了一个 nginx 容器。</span></span><br><span class="line">kubectl get deployment</span><br><span class="line">NAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">snowflake   2         2         2            2           2m</span><br><span class="line"></span><br><span class="line">kubectl get pods -l run=snowflake</span><br><span class="line">NAME                         READY     STATUS    RESTARTS   AGE</span><br><span class="line">snowflake-3968820950-9dgr8   1/1       Running   0          2m</span><br><span class="line">snowflake-3968820950-vgc4n   1/1       Running   0          2m</span><br></pre></td></tr></table></figure><ul><li>此时，开发人员可以做任何他想要做的操作，所有操作都限定在名称空间 <code>development</code> 里，而无需担心影响到 <code>production</code> 名称空间中的内容</li><li>用户在一个名称空间创建的内容对于另外一个名称空间来说是不可见的。同时也可以为不同的名称空间定义不同的访问权限控制。</li></ul><h2 id="为什么需要名称空间"><a href="#为什么需要名称空间" class="headerlink" title="为什么需要名称空间"></a>为什么需要名称空间</h2><p>一个Kubernetes集群应该可以满足多组用户的不同需要。Kubernetes名称空间可以使不同的项目、团队或客户共享同一个 Kubernetes 集群。实现的方式是，提供：</p><ul><li>namespace的作用域</li><li>为不同的名称空间定义不同的授权方式和资源分配策略 Resource Quota 和 resource limit range</li></ul><p>每一个用户组都期望独立于其他用户组进行工作。通过名称空间，每个用户组拥有自己的：</p><ul><li>Kubernetes 对象（Pod、Service、Deployment等）</li><li>授权（谁可以在该名称空间中执行操作）</li><li>资源分配（该用户组或名称空间可以使用集群中的多少计算资源）</li></ul><p>可能的使用情况有：</p><ul><li>集群管理员通过一个Kubernetes集群支持多个用户组</li><li>集群管理员将集群中某个名称空间的权限分配给用户组中的受信任的成员</li><li>集群管理员可以限定某一个用户组可以消耗的资源数量，以避免其他用户组受到影响</li><li>集群用户可以使用自己的Kubernetes对象，而不会与集群中的其他用户组相互干扰</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查看、创建、删除、使用namespace&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>操作Kubernetes</title>
    <link href="http://yoursite.com/2020/03/28/%E6%93%8D%E4%BD%9CKubernetes/"/>
    <id>http://yoursite.com/2020/03/28/%E6%93%8D%E4%BD%9CKubernetes/</id>
    <published>2020-03-28T02:24:30.000Z</published>
    <updated>2020-03-28T03:52:42.373Z</updated>
    
    <content type="html"><![CDATA[<p>什么是Kubernetes对象，管理Kubernetes对象，名称（name），名称空间（namespace）的概念</p><a id="more"></a> <h1 id="一、什么是Kubernetes对象"><a href="#一、什么是Kubernetes对象" class="headerlink" title="一、什么是Kubernetes对象"></a>一、什么是Kubernetes对象</h1><p>​    Kubernetes对象指的是Kubernetes系统的持久化实体，所有这些对象合起来，代表了集群的实际情况。常规的应用里，应用程序的数据存储在数据库中，Kubernetes将其数据以Kubernetes对象的形式通过 api server存储在 etcd 中。具体来说，这些数据（Kubernetes对象）描述了：</p><ul><li>集群中运行了哪些容器化应用程序（以及在哪个节点上运行）</li><li>集群中对应用程序可用的资源</li><li>应用程序相关的策略定义，例如，重启策略、升级策略、容错策略</li><li>其他Kubernetes管理应用程序时所需要的信息</li></ul><p>操作 Kubernetes 对象（创建、修改、删除）的方法主要有：</p><ul><li>kubectl 命令行工具</li><li>kuboard 图形界面工具</li></ul><p>kubectl、kuboard 最终都通过调用 kubernetes API 来实现对 Kubernetes 对象的操作。 </p><h2 id="对象的spec和status"><a href="#对象的spec和status" class="headerlink" title="对象的spec和status"></a>对象的spec和status</h2><p>每一个 Kubernetes 对象都包含了两个重要的字段：</p><ul><li><code>spec</code> 必须由您来提供，描述了您对该对象所期望的 <strong>目标状态</strong></li><li><code>status</code> 只能由 Kubernetes 系统来修改，描述了该对象在 Kubernetes 系统中的 <strong>实际状态</strong></li></ul><p>Kubernetes通过对应的控制器，不断地使实际状态趋向于期望的目标状态。</p><p>​        例如，一个 Kubernetes Deployment 对象可以代表一个应用程序在集群中的运行状态。当创建 Deployment 对象时，可以通过 Deployment 的 spec 字段指定需要运行应用程序副本数（假设为3）。Kubernetes 从 Deployment 的 spec 中读取这些信息，并创建指定容器化应用程序的 3 个副本，再将实际的状态更新到 Deployment 的 status 字段。Kubernetes 系统将不断地比较 <strong>实际状态</strong> staus 和 <strong>目标状态</strong> spec 之间的差异，并根据差异做出对应的调整。例如，如果任何一个副本运行失败了，Kubernetes 将启动一个新的副本，以替代失败的副本</p><h2 id="描述Kubernetes对象"><a href="#描述Kubernetes对象" class="headerlink" title="描述Kubernetes对象"></a>描述Kubernetes对象</h2><p>在 Kubernetes 中创建一个对象时，必须提供</p><ul><li>该对象的 spec 字段，通过该字段描述您期望的 <strong>目标状态</strong></li><li>该对象的一些基本信息，例如名字</li></ul><p>如果使用 kubectl 创建对象，必须编写 <code>.yaml</code> 格式的文件下面是一个 kubectl 可以使用的 <code>.yaml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 运行 2 个容器化应用程序副本</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p> 使用 kube apply 命令可以创建该 <code>.yaml</code> 文件中的 Deployment 对象： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl apply -f nginx-deployment.yaml </span></span><br><span class="line">deployment.apps/nginx-deployment created</span><br><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl get pod</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-54f57cf6bf-528xn   1/1     Running   0          4m35s</span><br><span class="line">nginx-deployment-54f57cf6bf-bgclh   1/1     Running   0          4m35s</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">[root@k8s-master k8s-yamls]<span class="comment"># kubectl delete -f nginx-deployment.yaml </span></span><br><span class="line">deployment.apps <span class="string">"nginx-deployment"</span> deleted</span><br></pre></td></tr></table></figure><h2 id="必填字段"><a href="#必填字段" class="headerlink" title="必填字段"></a>必填字段</h2><p>在上述的 <code>.yaml</code> 文件中，如下字段是必须填写的：</p><ul><li><strong>apiVersion</strong> 用来创建对象时所使用的Kubernetes API版本</li><li><strong>kind</strong> 被创建对象的类型</li><li><strong>metadata</strong> 用于唯一确定该对象的元数据：包括 <code>name</code> 和 <code>namespace</code>，如果 <code>namespace</code> 为空，则默认值为 <code>default</code></li><li><strong>spec</strong> 描述您对该对象的期望状态</li></ul><h1 id="二、管理Kubernetes对象"><a href="#二、管理Kubernetes对象" class="headerlink" title="二、管理Kubernetes对象"></a>二、管理Kubernetes对象</h1><h2 id="三种管理方式"><a href="#三种管理方式" class="headerlink" title="三种管理方式"></a>三种管理方式</h2><table><thead><tr><th>管理方式</th><th>操作对象</th><th>推荐的环境</th><th>参与编辑的人数</th><th>学习曲线</th></tr></thead><tbody><tr><td>指令性的命令行</td><td>Kubernetes对象</td><td>开发环境</td><td>1+</td><td>最低</td></tr><tr><td>指令性的对象配置</td><td>单个 yaml 文件</td><td>生产环境</td><td>1</td><td>适中</td></tr><tr><td>声明式的对象配置</td><td>包含多个 yaml 文件的多个目录</td><td>生产环境</td><td>1+</td><td>最高</td></tr></tbody></table><h2 id="指令性的命令行"><a href="#指令性的命令行" class="headerlink" title="指令性的命令行"></a>指令性的命令行</h2><p>当使用指令性的命令行（imperative commands）时，用户通过向 <code>kubectl</code> 命令提供参数的方式，直接操作集群中的 Kubernetes 对象。此时，用户无需编写或修改 <code>.yaml</code> 文件。</p><p>这是在 Kubernetes 集群中执行一次性任务的一个简便的办法。由于这种方式直接修改 Kubernetes 对象，也就无法提供历史配置查看的功能。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>创建一个 Deployment 对象，以运行一个 nginx 实例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run nginx --image nginx</span><br></pre></td></tr></table></figure><p>下面的命令完成了相同的任务，但是命令格式不同：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx --image nginx</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>与编写 <code>.yaml</code> 文件进行配置的方式相比的优势：</p><ul><li>命令简单，易学易记，只需要一个步骤，就可以对集群执行变更</li></ul><p>缺点：</p><ul><li>使用命令，无法进行变更review的管理；不提供日志审计；没有创建新对象的模板</li></ul><h2 id="指令性的对象配置"><a href="#指令性的对象配置" class="headerlink" title="指令性的对象配置"></a>指令性的对象配置</h2><p>使用指令性的对象配置（imperative object configuration）时，需要向 kubectl 命令指定具体的操作（create,replace,apply,delete等），可选参数以及至少一个配置文件的名字。配置文件中必须包括一个完整的对象的定义，可以是 yaml 格式，也可以是 json 格式。</p><p>通过配置文件创建对象 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f nginx.yaml</span><br></pre></td></tr></table></figure><p>删除两个配置文件中的对象 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f nginx.yaml -f redis.yaml</span><br></pre></td></tr></table></figure><p>直接使用配置文件中的对象定义，替换Kubernetes中对应的对象： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl replace -f nginx.yaml</span><br></pre></td></tr></table></figure><h2 id="声明式的对象配置"><a href="#声明式的对象配置" class="headerlink" title="声明式的对象配置"></a>声明式的对象配置</h2><p>当使用声明式的对象配置时，用户操作本地存储的Kubernetes对象配置文件，然而，在将文件传递给 kubectl 命令时，并不指定具体的操作，由 kubectl 自动检查每一个对象的状态并自行决定是创建、更新、还是删除该对象。使用这种方法时，可以直接针对一个或多个文件目录进行操作（对不同的对象可能需要执行不同的操作）。</p><p>处理 <code>configs</code> 目录中所有配置文件中的Kubernetes对象，根据情况创建对象、或更新Kubernetes中已经存在的对象。可以先执行 <code>diff</code> 指令查看具体的变更，然后执行 <code>apply</code> 指令执行变更： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl diff -f configs/</span><br><span class="line">kubectl apply -f configs/</span><br><span class="line"></span><br><span class="line"><span class="comment">#递归处理目录中的内容</span></span><br><span class="line">kubectl diff -R -f configs/</span><br><span class="line">kubectl apply -R -f configs/</span><br></pre></td></tr></table></figure><h1 id="三、名称"><a href="#三、名称" class="headerlink" title="三、名称"></a>三、名称</h1><p> Kubernetes REST API 中，所有的对象都是通过 <code>name</code> 和 <code>UID</code> 唯一性确定。 </p><h2 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h2><p> 同一个名称空间下，同一个类型的对象，可以通过 <code>name</code> 唯一性确定。如果删除该对象之后，可以再重新创建一个同名对象。 </p><p> 例如，下面的配置文件定义了一个 name 为 <code>nginx-demo</code> 的 Pod，该 Pod 包含一个 name 为 <code>nginx</code> 的容器： </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h2 id="UIDs"><a href="#UIDs" class="headerlink" title="UIDs"></a>UIDs</h2><p>UID 是由 Kubernetes 系统生成的，唯一标识某个 Kubernetes 对象的字符串。</p><p>Kubernetes集群中，每创建一个对象，都有一个唯一的 UID。用于区分多次创建的同名对象（如前所述，按照名字删除对象后，重新再创建同名对象时，两次创建的对象 name 相同，但是 UID 不同。）</p><h1 id="四、名称空间"><a href="#四、名称空间" class="headerlink" title="四、名称空间"></a>四、名称空间</h1><h2 id="何时使用名称空间"><a href="#何时使用名称空间" class="headerlink" title="何时使用名称空间"></a>何时使用名称空间</h2><ol><li>名称空间的用途是，为不同团队的用户（或项目）提供虚拟的集群空间（划分集群的资源），也可以用来区分开发环境/测试环境、准上线环境/生产环境。</li><li>名称空间为<code>名称</code>提供了作用域。名称空间内部的同类型对象不能重名，但是跨名称空间可以有同名同类型对象。名称空间不可以嵌套，任何一个Kubernetes对象只能在一个名称空间中。</li><li>在 Kubernetes 将来的版本中，同名称空间下的对象将默认使用相同的访问控制策略。</li><li>当Kubernetes对象之间的差异不大时，无需使用名称空间来区分，例如，同一个软件的不同版本，只需要使用 labels 来区分即可。</li></ol><h2 id="如何使用名称空间"><a href="#如何使用名称空间" class="headerlink" title="如何使用名称空间"></a>如何使用名称空间</h2><h3 id="查看名称空间"><a href="#查看名称空间" class="headerlink" title="查看名称空间"></a>查看名称空间</h3><p>执行命令 <code>kubectl get namespaces</code> 可以查看名称空间</p><p>Kubernetes 安装成功后，默认有初始化了三个名称空间：</p><ul><li><strong>default</strong> 默认名称空间，如果 Kubernetes 对象中不定义 <code>metadata.namespace</code> 字段，该对象将放在此名称空间下</li><li><strong>kube-system</strong> Kubernetes系统创建的对象放在此名称空间下</li><li><strong>kube-public</strong> 此名称空间自动在安装集群是自动创建，并且所有用户都是可以读取的（即使是那些未登录的用户）。主要是为集群预留的，例如，某些情况下，某些Kubernetes对象应该被所有集群用户看到。</li></ul><h3 id="在执行请求时设定namespace"><a href="#在执行请求时设定namespace" class="headerlink" title="在执行请求时设定namespace"></a>在执行请求时设定namespace</h3><p>执行 kubectl 命令时，可以使用 <code>--namespace</code> 参数指定名称空间，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl run nginx --image=nginx --namespace=&lt;your_namespace&gt;</span><br><span class="line">kubectl get pods --namespace=&lt;your_namespace&gt;</span><br></pre></td></tr></table></figure><h3 id="设置名称空间偏好"><a href="#设置名称空间偏好" class="headerlink" title="设置名称空间偏好"></a>设置名称空间偏好</h3><p>可以通过 <code>set-context</code> 命令改变当前<code>kubectl 上下文</code>的名称空间，后续所有命令都默认在此名称空间下执行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-context --current --namespace=&lt;your_namespace&gt;</span><br><span class="line"><span class="comment"># 验证结果</span></span><br><span class="line">kubectl config view --minify | grep namespace:</span><br></pre></td></tr></table></figure><h2 id="名称空间与DNS"><a href="#名称空间与DNS" class="headerlink" title="名称空间与DNS"></a>名称空间与DNS</h2><p>当创建一个 Service 时，Kubernetes 为其创建一个对应的<code>DNS 条目</code>。该 DNS 记录的格式为  <code>&lt;service-name&gt;.&lt;namespace-name&gt;.svc.cluster.local</code> ，也就是说，如果在容器中只使用 <code>&lt;service-name&gt;</code> ，其DNS将解析到同名称空间下的 Service。这个特点在多环境的情况下非常有用，例如将开发环境、测试环境、生产环境部署在不同的名称空间下，应用程序只需要使用<code>&lt;service-name&gt;</code>即可进行服务发现，无需为不同的环境修改配置。如果跨名称空间访问服务，则必须使用完整的域名（fully qualified domain name，FQDN）。</p><h2 id="并非所有对象都在名称空间里"><a href="#并非所有对象都在名称空间里" class="headerlink" title="并非所有对象都在名称空间里"></a>并非所有对象都在名称空间里</h2><p>大部分的 Kubernetes 对象（例如，Pod、Service、Deployment、StatefulSet等）都必须在名称空间里。但是某些更低层级的对象，是不在任何名称空间中的，例如nodes、persistentVolumes、storageClass等</p><p>执行一下命令可查看哪些 Kubernetes 对象在名称空间里，哪些不在：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在名称空间里</span></span><br><span class="line">kubectl api-resources --namespaced=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不在名称空间里</span></span><br><span class="line">kubectl api-resources --namespaced=<span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是Kubernetes对象，管理Kubernetes对象，名称（name），名称空间（namespace）的概念&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>kubeadm安装Kubernetes1.16.3</title>
    <link href="http://yoursite.com/2020/03/27/kubeadm%E5%AE%89%E8%A3%85Kubernetes1-16-3/"/>
    <id>http://yoursite.com/2020/03/27/kubeadm%E5%AE%89%E8%A3%85Kubernetes1-16-3/</id>
    <published>2020-03-27T07:11:48.000Z</published>
    <updated>2020-03-27T07:39:50.190Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统环境：</strong></p><ul><li>CentOS 版本：7.7</li><li>Docker 版本：18.09.9-3</li><li>Calico 版本：v3.10</li><li>Kubernetes 版本：1.16.3</li><li>Kubernetes Newwork 模式：IPVS</li><li>Kubernetes Dashboard 版本：dashboard:v2.0.0-beta6</li></ul><a id="more"></a> <h2 id="一、更新系统内核（全部节点）"><a href="#一、更新系统内核（全部节点）" class="headerlink" title="一、更新系统内核（全部节点）"></a>一、更新系统内核（全部节点）</h2><p>由于 Docker 对系统内核有一定的要求，所以我们最好使用 yum 来更新系统软件及其内核。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#备份本地 yum 源</span></span><br><span class="line">$ mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo_bak </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取阿里 yum 源配置文件</span></span><br><span class="line">$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo </span><br><span class="line"></span><br><span class="line"><span class="comment">#清理 yum</span></span><br><span class="line">$ yum clean all</span><br><span class="line"></span><br><span class="line"><span class="comment">#更新软件版本并且更新现有软件</span></span><br><span class="line">$ yum -y update</span><br></pre></td></tr></table></figure><h2 id="二、基础环境设置（全部节点）"><a href="#二、基础环境设置（全部节点）" class="headerlink" title="二、基础环境设置（全部节点）"></a>二、基础环境设置（全部节点）</h2><p>Kubernetes 需要一定的环境来保证正常运行，如各个节点时间同步，主机名称解析，关闭防火墙等等。</p><h3 id="1、修改-Host"><a href="#1、修改-Host" class="headerlink" title="1、修改 Host"></a>1、修改 Host</h3><p>分布式系统环境中的多主机通信通常基于主机名称进行，这在 IP 地址存在变化的可能 性时为主机提供了固定的访问人口，因此一般需要有专用的 DNS 服务负责解析各节点主机。考虑到此处部署的是测试集群，因此为了降低系复杂度，这里将基于 hosts 的文件进行主机名称解析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/hosts</span><br></pre></td></tr></table></figure><p>加入下面内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.2.11   k8s-master</span><br><span class="line">192.168.2.12   k8s-node-01</span><br><span class="line">192.168.2.13   k8s-node-02</span><br></pre></td></tr></table></figure><h3 id="2、修改-Hostname"><a href="#2、修改-Hostname" class="headerlink" title="2、修改 Hostname"></a>2、修改 Hostname</h3><p>kubernetes 中会以各个服务的 hostname 为其节点命名，所以需要进入不同的服务器修改 hostname 名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改 192.168.2.11 服务器，设置 hostname，然后将 hostname 写入 hosts</span></span><br><span class="line">$ hostnamectl  <span class="built_in">set</span>-hostname  k8s-master</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"127.0.0.1   <span class="variable">$(hostname)</span>"</span> &gt;&gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改 192.168.2.12 服务器，设置 hostname，然后将 hostname 写入 hosts</span></span><br><span class="line">$ hostnamectl  <span class="built_in">set</span>-hostname  k8s-node-01</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"127.0.0.1   <span class="variable">$(hostname)</span>"</span> &gt;&gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改 192.168.2.13 服务器，设置 hostname，然后将 hostname 写入 hosts</span></span><br><span class="line">$ hostnamectl  <span class="built_in">set</span>-hostname  k8s-node-02</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"127.0.0.1   <span class="variable">$(hostname)</span>"</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h3 id="3、主机时间同步"><a href="#3、主机时间同步" class="headerlink" title="3、主机时间同步"></a>3、主机时间同步</h3><p>将各个服务器的时间同步，并设置开机启动同步时间服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start chronyd.service &amp;&amp; systemctl <span class="built_in">enable</span> chronyd.service</span><br></pre></td></tr></table></figure><h3 id="4、关闭防火墙服务"><a href="#4、关闭防火墙服务" class="headerlink" title="4、关闭防火墙服务"></a>4、关闭防火墙服务</h3><p>关闭防火墙，并禁止开启启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld &amp;&amp; systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><h3 id="5、关闭并禁用SELinux"><a href="#5、关闭并禁用SELinux" class="headerlink" title="5、关闭并禁用SELinux"></a>5、关闭并禁用SELinux</h3><p>关闭SELinux，并编辑／etc/sysconfig selinux 文件，以彻底禁用 SELinux</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ setenforce 0</span><br><span class="line">$ sed -i <span class="string">'s/^SELINUX=enforcing$/SELINUX=disabled/'</span> /etc/selinux/config</span><br></pre></td></tr></table></figure><p>查看selinux状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ getenforce</span><br></pre></td></tr></table></figure><h3 id="6、禁用-Swap-设备"><a href="#6、禁用-Swap-设备" class="headerlink" title="6、禁用 Swap 设备"></a>6、禁用 Swap 设备</h3><p>关闭当前已启用的所有 Swap 设备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swapoff -a &amp;&amp; sysctl -w vm.swappiness=0</span><br></pre></td></tr></table></figure><p>编辑 fstab 配置文件，注释掉标识为 Swap 设备的所有行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment">#/dev/mapper/centos-swap swap  swap  defaults  0 0</span></span><br></pre></td></tr></table></figure><h3 id="7、设置内核参数"><a href="#7、设置内核参数" class="headerlink" title="7、设置内核参数"></a>7、设置内核参数</h3><p>配置内核参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.conf</span><br><span class="line"></span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 30</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 10</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>使配置生效:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#挂载 br_netfilter</span></span><br><span class="line">$ modprobe br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="comment">#使配置生效</span></span><br><span class="line">$ sysctl -p /etc/sysctl.d/k8s.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是否生成相关文件</span></span><br><span class="line">$ ls /proc/sys/net/bridge</span><br></pre></td></tr></table></figure><h3 id="8、配置-IPVS-模块"><a href="#8、配置-IPVS-模块" class="headerlink" title="8、配置 IPVS 模块"></a>8、配置 IPVS 模块</h3><p>由于ipvs已经加入到了内核的主干，所以为kube-proxy开启ipvs的前提需要加载以下的内核模块：</p><ul><li>ip_vs</li><li>ip_vs_rr</li><li>ip_vs_wrr</li><li>ip_vs_sh</li><li>nf_conntrack_ipv4</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>执行脚本并查看是否正常加载内核模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改脚本权限</span></span><br><span class="line">$ chmod 755 /etc/sysconfig/modules/ipvs.modules </span><br><span class="line"></span><br><span class="line"><span class="comment">#执行脚本</span></span><br><span class="line">$ bash /etc/sysconfig/modules/ipvs.modules </span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是否已经正确加载所需的内核模块</span></span><br><span class="line">$ lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span><br></pre></td></tr></table></figure><p>安装 ipset</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y ipset</span><br></pre></td></tr></table></figure><h3 id="9、配置资源限制"><a href="#9、配置资源限制" class="headerlink" title="9、配置资源限制"></a>9、配置资源限制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"* soft nofile 65536"</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"* hard nofile 65536"</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"* soft nproc 65536"</span>  &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"* hard nproc 65536"</span>  &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"* soft memlock  unlimited"</span>  &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"* hard memlock  unlimited"</span>  &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure><h3 id="10、安装依赖包以及相关工具"><a href="#10、安装依赖包以及相关工具" class="headerlink" title="10、安装依赖包以及相关工具"></a>10、安装依赖包以及相关工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y epel-release</span><br><span class="line">$ yum install -y yum-utils device-mapper-persistent-data lvm2 net-tools conntrack-tools wget vim ntpdate libseccomp libtool-ltdl</span><br></pre></td></tr></table></figure><h2 id="三、安装Docker（全部节点）"><a href="#三、安装Docker（全部节点）" class="headerlink" title="三、安装Docker（全部节点）"></a>三、安装Docker（全部节点）</h2><h3 id="1、移除之前安装过的Docker"><a href="#1、移除之前安装过的Docker" class="headerlink" title="1、移除之前安装过的Docker"></a>1、移除之前安装过的Docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum -y remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-ce-cli \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><p>查看还有没有存在的 Docker 组件，一定要确保删除干净：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -qa | grep docker</span><br></pre></td></tr></table></figure><p>有则通过命令 yum -y remove XXX 来删除，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum remove docker-ce-cli</span><br></pre></td></tr></table></figure><h3 id="2、更换-Docker-的-yum-源"><a href="#2、更换-Docker-的-yum-源" class="headerlink" title="2、更换 Docker 的 yum 源"></a>2、更换 Docker 的 yum 源</h3><p>由于官方下载速度比较慢，所以需要更改 Docker 安装的 yum 源，这里推荐用阿里镜像源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="3、显示-docker-所有可安装版本："><a href="#3、显示-docker-所有可安装版本：" class="headerlink" title="3、显示 docker 所有可安装版本："></a>3、显示 docker 所有可安装版本：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><h3 id="、安装指定版本-docker"><a href="#、安装指定版本-docker" class="headerlink" title="、安装指定版本 docker"></a>、安装指定版本 docker</h3><blockquote><p>注意：安装前一定要提前查询将要安装的 Kubernetes 版本是否和 Docker 版本对应。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y docker-ce-18.09.9-3.el7</span><br></pre></td></tr></table></figure><p>设置镜像存储目录，找到大点的挂载的目录进行存储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vi /lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line"><span class="comment">#找到这行，往后面加上存储目录，例如这里是 --graph /apps/docker</span></span><br><span class="line">ExecStart=/usr/bin/docker --graph /apps/docker</span><br></pre></td></tr></table></figure><h3 id="5、配置-Docker-参数和镜像加速器"><a href="#5、配置-Docker-参数和镜像加速器" class="headerlink" title="5、配置 Docker 参数和镜像加速器"></a>5、配置 Docker 参数和镜像加速器</h3><p>Kubernetes 推荐的一些 Docker 配置参数，这里配置一下。还有就是由于国内访问 Docker 仓库速度很慢，所以国内几家云厂商推出镜像加速下载的代理加速器，这里也需要配置一下。</p><p>创建 Docker 配置文件的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /etc/docker</span><br></pre></td></tr></table></figure><p>添加配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"exec-opts"</span>: [<span class="string">"native.cgroupdriver=systemd"</span>],</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">      <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">      <span class="string">"http://hub-mirror.c.163.com"</span>,</span><br><span class="line">      <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"storage-driver"</span>: <span class="string">"overlay2"</span>,</span><br><span class="line">  <span class="string">"storage-opts"</span>: [</span><br><span class="line">    <span class="string">"overlay2.override_kernel_check=true"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"log-driver"</span>: <span class="string">"json-file"</span>,</span><br><span class="line">  <span class="string">"log-opts"</span>: &#123;</span><br><span class="line">    <span class="string">"max-size"</span>: <span class="string">"100m"</span>,</span><br><span class="line">    <span class="string">"max-file"</span>:<span class="string">"5"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="6、启动-docker-并设置-docker-开机启动"><a href="#6、启动-docker-并设置-docker-开机启动" class="headerlink" title="6、启动 docker 并设置 docker 开机启动"></a>6、启动 docker 并设置 docker 开机启动</h3><p>启动 Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start docker &amp;&amp; systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p>如果 Docker 已经启动，则需要重启 Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="四、安装-kubelet、kubectl、kubeadm（全部节点）"><a href="#四、安装-kubelet、kubectl、kubeadm（全部节点）" class="headerlink" title="四、安装 kubelet、kubectl、kubeadm（全部节点）"></a>四、安装 kubelet、kubectl、kubeadm（全部节点）</h2><h3 id="1、配置可用的国内-yum-源"><a href="#1、配置可用的国内-yum-源" class="headerlink" title="1、配置可用的国内 yum 源"></a>1、配置可用的国内 yum 源</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">&lt;&lt;EOF</span> <span class="string">&gt;</span> <span class="string">/etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=0</span></span><br><span class="line"><span class="string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span> <span class="string">https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h3 id="2、安装-kubelet、kubectl、kubeadm"><a href="#2、安装-kubelet、kubectl、kubeadm" class="headerlink" title="2、安装 kubelet、kubectl、kubeadm"></a>2、安装 kubelet、kubectl、kubeadm</h3><ul><li>kubelet: 在集群中的每个节点上用来启动 pod 和 container 等。</li><li>kubectl: 用来与集群通信的命令行工具。</li><li>kubeadm: 用来初始化集群的指令。</li></ul><blockquote><p>注意安装顺序，一定不要先安装 kubeadm，因为 kubeadm 会自动安装最新版本的 kubelet 与 kubectl，导致版本不一致问题。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装 kubelet</span></span><br><span class="line">$ yum install -y kubelet-1.16.3-0</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装 kubectl</span></span><br><span class="line">$ yum install -y kubectl-1.16.3-0</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装 kubeadm</span></span><br><span class="line">$ yum install -y kubeadm-1.16.3-0</span><br></pre></td></tr></table></figure><h3 id="3、启动-kubelet-并配置开机启动"><a href="#3、启动-kubelet-并配置开机启动" class="headerlink" title="3、启动 kubelet 并配置开机启动"></a>3、启动 kubelet 并配置开机启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start kubelet &amp;&amp; systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure><blockquote><p>检查状态时会发现 kubelet 是 failed 状态，等初 master 节点初始化完成后即可显示正常。</p></blockquote><h2 id="五、重启服务器（全部节点）"><a href="#五、重启服务器（全部节点）" class="headerlink" title="五、重启服务器（全部节点）"></a>五、重启服务器（全部节点）</h2><p>为了防止发生某些未知错误，这里我们重启下服务器，方便进行后续操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ reboot</span><br></pre></td></tr></table></figure><h2 id="六、kubeadm-安装-kubernetes（Master-节点）"><a href="#六、kubeadm-安装-kubernetes（Master-节点）" class="headerlink" title="六、kubeadm 安装 kubernetes（Master 节点）"></a>六、kubeadm 安装 kubernetes（Master 节点）</h2><p>创建 kubeadm 配置文件 kubeadm-config.yaml，然后需要配置一些参数：</p><ul><li>配置 localAPIEndpoint.advertiseAddress 参数，调整为你的 Master 服务器地址。</li><li>配置 imageRepository 参数，调整 kubernetes 镜像下载地址为阿里云。</li><li>配置 networking.podSubnet 参数，调整为你要设置的网络范围。</li></ul><p><strong>kubeadm-config.yaml</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; kubeadm-config.yaml &lt;&lt; EOF</span><br><span class="line"></span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 192.168.2.11</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  taints:</span><br><span class="line">  - effect: PreferNoSchedule</span><br><span class="line">    key: node-role.kubernetes.io/master</span><br><span class="line">---</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers</span><br><span class="line">kubernetesVersion: v1.16.3</span><br><span class="line">networking:</span><br><span class="line">  podSubnet: 10.244.0.0/16</span><br><span class="line">---</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">mode: ipvs</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>kubeadm 初始化 kubernetes 集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm init --config kubeadm-config.yaml</span><br></pre></td></tr></table></figure><p>部署日志信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.2.11:6443 --token 4udy8a.f77ai0zun477kx0p \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4645472f24b438e0ecf5964b6dcd64913f68e0f9f7458768cfb96a9ab16b4212</span><br></pre></td></tr></table></figure><p>上面记录了完成的初始化输出的内容，根据输出的内容基本上可以看出手动初始化安装一个Kubernetes集群所需要的关键步骤。</p><p>其中有以下关键内容：</p><ul><li><code>[kubelet]</code> 生成kubelet的配置文件”/var/lib/kubelet/config.yaml”</li><li><code>[certificates]</code>生成相关的各种证书</li><li><code>[kubeconfig]</code>生成相关的kubeconfig文件</li><li><code>[bootstraptoken]</code>生成token记录下来，后边使用<code>kubeadm join</code>往集群中添加节点时会用到</li></ul><p>在此处看日志可以知道，可以通过下面命令，添加 kubernetes 相关环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">$ sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">$ sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><p>或者直接只用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">   --kubernetes-version=v1.16.3 \</span><br><span class="line">   --pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">   --apiserver-advertise-address=192.168.2.11 \</span><br><span class="line">   --ignore-preflight-errors=Swap</span><br></pre></td></tr></table></figure><p> 提前拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images pull --config kubeadm-master.config</span><br></pre></td></tr></table></figure><blockquote><p>安装过程中遇到异常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy[preflight] Some fatal errors occurred:</span><br><span class="line">[ERROR DirAvailable--var-lib-etcd]: /var/lib/etcd is not empty</span><br></pre></td></tr></table></figure><p>直接删除/var/lib/etcd文件夹</p></blockquote><hr><p><strong>如果初始化过程出现问题，使用如下命令重置：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><h2 id="七、工作节点加入集群（Work-Node-节点）"><a href="#七、工作节点加入集群（Work-Node-节点）" class="headerlink" title="七、工作节点加入集群（Work Node 节点）"></a>七、工作节点加入集群（Work Node 节点）</h2><p>根据上面 Master 节点创建 Kubernetes 集群时的日志信息，可以知道在各个节点上执行下面命令来让工作节点加入主节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm join 192.168.2.11:6443 --token 4udy8a.f77ai0zun477kx0p \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4645472f24b438e0ecf5964b6dcd64913f68e0f9f7458768cfb96a9ab16b4212</span><br></pre></td></tr></table></figure><h2 id="八、部署网络插件（Master-节点）"><a href="#八、部署网络插件（Master-节点）" class="headerlink" title="八、部署网络插件（Master 节点）"></a>八、部署网络插件（Master 节点）</h2><p>Kubernetes 中可以部署很多种网络插件，不过比较流行也推荐的有两种：</p><ul><li><strong>Flannel：</strong> Flannel 是基于 Overlay 网络模型的网络插件，能够方便部署，一般部署后只要不出问题，一般不需要管它。</li><li><strong>Calico：</strong> 与 Flannel 不同，Calico 是一个三层的数据中心网络方案，使用 BGP 路由协议在主机之间路由数据包，可以灵活配置网络策略。</li></ul><p>这两种网络根据环境任选其一即可，这里使用的是 Calico，可以按下面步骤部署：</p><h3 id="1、部署-Calico-网络插件"><a href="#1、部署-Calico-网络插件" class="headerlink" title="1、部署 Calico 网络插件"></a>1、部署 Calico 网络插件</h3><p>下载 Calico 部署文件，并替换里面的网络范围为上面 kubeadm 中 networking.podSubnet 配置的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载 calico 部署文件</span></span><br><span class="line">$ wget https://docs.projectcalico.org/v3.10/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml </span><br><span class="line"></span><br><span class="line"><span class="comment">#替换 calico 部署文件的 IP 为 kubeadm 中的 networking.podSubnet 参数 10.244.0.0。</span></span><br><span class="line">$ sed -i <span class="string">'s/192.168.0.0/10.244.0.0/g'</span> calico.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署 Calico 插件</span></span><br><span class="line">$ kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure><h3 id="2、查看-Pod-是否成功启动"><a href="#2、查看-Pod-是否成功启动" class="headerlink" title="2、查看 Pod 是否成功启动"></a>2、查看 Pod 是否成功启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod -n kube-system</span><br><span class="line"></span><br><span class="line">NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">calico-kube-controllers-6b64bcd855-jn8pz   1/1     Running   0          2m40s</span><br><span class="line">calico-node-5wssd                          1/1     Running   0          2m40s</span><br><span class="line">calico-node-7tw94                          1/1     Running   0          2m40s</span><br><span class="line">calico-node-xzfp4                          1/1     Running   0          2m40s</span><br><span class="line">coredns-58cc8c89f4-hv4fn                   1/1     Running   0          21m</span><br><span class="line">coredns-58cc8c89f4-k97x6                   1/1     Running   0          21m</span><br><span class="line">etcd-k8s-master                            1/1     Running   0          20m</span><br><span class="line">kube-apiserver-k8s-master                  1/1     Running   0          20m</span><br><span class="line">kube-controller-manager-k8s-master         1/1     Running   0          20m</span><br><span class="line">kube-proxy-9dlpz                           1/1     Running   0          14m</span><br><span class="line">kube-proxy-krd5n                           1/1     Running   0          14m</span><br><span class="line">kube-proxy-tntpr                           1/1     Running   0          21m</span><br><span class="line">kube-scheduler-k8s-master                  1/1     Running   0          20m</span><br></pre></td></tr></table></figure><p>可以看到所以 Pod 都已经成功启动。</p><h2 id="九、配置-Kubectl-命令自动补全（Master-节点）"><a href="#九、配置-Kubectl-命令自动补全（Master-节点）" class="headerlink" title="九、配置 Kubectl 命令自动补全（Master 节点）"></a>九、配置 Kubectl 命令自动补全（Master 节点）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y bash-completion</span><br></pre></td></tr></table></figure><p>添加补全配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ source &#x2F;usr&#x2F;share&#x2F;bash-completion&#x2F;bash_completion</span><br><span class="line">$ source &lt;(kubectl completion bash)</span><br><span class="line">$ echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>添加完成就可与通过输入 kubectl 后，按补全键（一般为 tab）会自动补全对应的命令。</p><h2 id="十、查看是否开启-IPVS（Master-节点）"><a href="#十、查看是否开启-IPVS（Master-节点）" class="headerlink" title="十、查看是否开启 IPVS（Master 节点）"></a>十、查看是否开启 IPVS（Master 节点）</h2><p>上面全部组件都已经部署完成，不过还需要确认是否成功将网络模式设置为 IPVS，可以查看 kube-proxy 日志，在日志信息中查找是否存在 IPVS 关键字信息来确认。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod -n kube-system | grep kube-proxy</span><br><span class="line"></span><br><span class="line">kube-proxy-9dlpz                           1/1     Running   0          42m</span><br><span class="line">kube-proxy-krd5n                           1/1     Running   0          42m</span><br><span class="line">kube-proxy-tntpr                           1/1     Running   0          49m</span><br></pre></td></tr></table></figure><p>选择其中一个 Pod ，查看该 Pod 中的日志信息中是否存在 ipvs 信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs kube-proxy-9dlpz -n kube-system</span><br><span class="line"></span><br><span class="line">I1120 18:13:46.357178       1 node.go:135] Successfully retrieved node IP: 192.168.2.13</span><br><span class="line">I1120 18:13:46.357265       1 server_others.go:176] Using ipvs Proxier.</span><br><span class="line">W1120 18:13:46.358005       1 proxier.go:420] IPVS scheduler not specified, use rr by default</span><br><span class="line">I1120 18:13:46.358919       1 server.go:529] Version: v1.16.3</span><br><span class="line">I1120 18:13:46.359327       1 conntrack.go:100] Set sysctl &#39;net&#x2F;netfilter&#x2F;nf_conntrack_max&#39; to 131072</span><br><span class="line">I1120 18:13:46.359379       1 conntrack.go:52] Setting nf_conntrack_max to 131072</span><br><span class="line">I1120 18:13:46.359426       1 conntrack.go:100] Set sysctl &#39;net&#x2F;netfilter&#x2F;nf_conntrack_tcp_timeout_established&#39; to 86400</span><br><span class="line">I1120 18:13:46.359452       1 conntrack.go:100] Set sysctl &#39;net&#x2F;netfilter&#x2F;nf_conntrack_tcp_timeout_close_wait&#39; to 3600</span><br><span class="line">I1120 18:13:46.359626       1 config.go:313] Starting service config controller</span><br><span class="line">I1120 18:13:46.359685       1 shared_informer.go:197] Waiting for caches to sync for service config</span><br><span class="line">I1120 18:13:46.359833       1 config.go:131] Starting endpoints config controller</span><br><span class="line">I1120 18:13:46.359889       1 shared_informer.go:197] Waiting for caches to sync for endpoints config</span><br><span class="line">I1120 18:13:46.460013       1 shared_informer.go:204] Caches are synced for service config </span><br><span class="line">I1120 18:13:46.460062       1 shared_informer.go:204] Caches are synced for endpoints config</span><br></pre></td></tr></table></figure><p>如上，在日志中查到了 IPVS 字样，则代表使用了 IPVS 模式。</p><h2 id="十一、集群中移除Node"><a href="#十一、集群中移除Node" class="headerlink" title="十一、集群中移除Node"></a>十一、集群中移除Node</h2><p> 如果需要从集群中移除node2这个Node执行下面的命令： </p><p> 在master节点上执行： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain node2 --delete-local-data --force --ignore-daemonsets </span><br><span class="line"></span><br><span class="line">kubectl delete node node2</span><br></pre></td></tr></table></figure><p> 在node2上执行： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset </span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">rm -rf &#x2F;var&#x2F;lib&#x2F;cni&#x2F;</span><br></pre></td></tr></table></figure><h2 id="十二、部署-Kubernetes-Dashboard"><a href="#十二、部署-Kubernetes-Dashboard" class="headerlink" title="十二、部署 Kubernetes Dashboard"></a>十二、部署 Kubernetes Dashboard</h2><p>接下来我们将部署 Kubernetes 的控制看板，由于集群为 1.16.3，而 Dashboard 的稳定版本还是基于 Kubernetes 1.10 版本，所以我们直接使用 Kubernetes Dashboard 2.0.0 Bate 版本，虽然为测试版本，不过它比较新，对新版本的兼容还是比旧版本好些，坐等它稳定，这里先部署尝尝鲜。</p><h3 id="1、创建-Dashboard-部署文件"><a href="#1、创建-Dashboard-部署文件" class="headerlink" title="1、创建 Dashboard 部署文件"></a>1、创建 Dashboard 部署文件</h3><p><strong>k8s-dashboard-deploy.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">&gt;</span> <span class="string">k8s-dashboard-deploy.yaml</span> <span class="string">&lt;&lt;</span> <span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># Allow Dashboard to get, update and delete Dashboard exclusive secrets.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["secrets"]</span></span><br><span class="line">    <span class="attr">resourceNames:</span> <span class="string">["kubernetes-dashboard-key-holder",</span> <span class="string">"kubernetes-dashboard-certs"</span><span class="string">,</span> <span class="string">"kubernetes-dashboard-csrf"</span><span class="string">]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"update"</span><span class="string">,</span> <span class="string">"delete"</span><span class="string">]</span></span><br><span class="line">    <span class="comment"># Allow Dashboard to get and update 'kubernetes-dashboard-settings' config map.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["configmaps"]</span></span><br><span class="line">    <span class="attr">resourceNames:</span> <span class="string">["kubernetes-dashboard-settings"]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"update"</span><span class="string">]</span></span><br><span class="line">    <span class="comment"># Allow Dashboard to get metrics.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["services"]</span></span><br><span class="line">    <span class="attr">resourceNames:</span> <span class="string">["heapster",</span> <span class="string">"dashboard-metrics-scraper"</span><span class="string">]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["proxy"]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["services/proxy"]</span></span><br><span class="line">    <span class="attr">resourceNames:</span> <span class="string">["heapster",</span> <span class="string">"http:heapster:"</span><span class="string">,</span> <span class="string">"https:heapster:"</span><span class="string">,</span> <span class="string">"dashboard-metrics-scraper"</span><span class="string">,</span> <span class="string">"http:dashboard-metrics-scraper"</span><span class="string">]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["get"]</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># Allow Metrics Scraper to get metrics from the Metrics server</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">["metrics.k8s.io"]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["pods",</span> <span class="string">"nodes"</span><span class="string">]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">]</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-csrf</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">csrf:</span> <span class="string">""</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-key-holder</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-settings</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30001</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">kubernetesui/dashboard:v2.0.0-beta6</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8443</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--auto-generate-certificates</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--namespace=kube-system</span>          <span class="comment">#设置为当前namespace</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/certs</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tmp</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">tmp-volume</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTPS</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8443</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">          <span class="attr">secret:</span></span><br><span class="line">            <span class="attr">secretName:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tmp-volume</span></span><br><span class="line">          <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">          <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">          </span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>部署 Kubernetes Dashboard</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f k8s-dashboard-deploy.yaml</span><br></pre></td></tr></table></figure><h3 id="2、创建监控信息-kubernetes-metrics-scraper"><a href="#2、创建监控信息-kubernetes-metrics-scraper" class="headerlink" title="2、创建监控信息 kubernetes-metrics-scraper"></a>2、创建监控信息 kubernetes-metrics-scraper</h3><p><strong>k8s-dashboard-metrics.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">&gt;</span> <span class="string">k8s-dashboard-metrics.yaml</span> <span class="string">&lt;&lt;</span> <span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-metrics-scraper</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8000</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-metrics-scraper</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-metrics-scraper</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-metrics-scraper</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">kubernetes-metrics-scraper</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">kubernetes-metrics-scraper</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-metrics-scraper</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">kubernetesui/metrics-scraper:v1.0.1</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8000</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">          <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">          </span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>部署 Dashboard Metrics</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f k8s-dashboard-metrics.yaml</span><br></pre></td></tr></table></figure><h3 id="3、创建-Dashboard-ServiceAccount"><a href="#3、创建-Dashboard-ServiceAccount" class="headerlink" title="3、创建 Dashboard ServiceAccount"></a>3、创建 Dashboard ServiceAccount</h3><p>访问 Kubernetes Dashboard 时会验证身份，需要提前在 Kubernetes 中创建一个一定权限的 ServiceAccount，然后获取其 Token 串，这里为了简单方便，直接创建一个与管理员绑定的服务账户，获取其 Token 串。</p><p><strong>k8s-dashboard-rbac.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">&gt;</span> <span class="string">k8s-dashboard-token.yaml</span> <span class="string">&lt;&lt;</span> <span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">rbac.authorization.kubernetes.io/autoupdate:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="attr">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br><span class="line">    </span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>部署访问的 ServiceAccount：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f k8s-dashboard-rbac.yaml</span><br></pre></td></tr></table></figure><p>获取 Token：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe secret/$(kubectl get secret -n kube-system |grep admin|awk <span class="string">'&#123;print $1&#125;'</span>) -n kube-system</span><br></pre></td></tr></table></figure><p> 然后输入 Kubernetes 集群任意节点地址配置上面配置的 Service 的 NodePort 30001 来访问看板。输入地址<a href="https://192.168.2.11:30001进入看板页面，输入上面获取的">https://192.168.2.11:30001进入看板页面，输入上面获取的</a> Token 串进行验证登录。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;系统环境：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS 版本：7.7&lt;/li&gt;
&lt;li&gt;Docker 版本：18.09.9-3&lt;/li&gt;
&lt;li&gt;Calico 版本：v3.10&lt;/li&gt;
&lt;li&gt;Kubernetes 版本：1.16.3&lt;/li&gt;
&lt;li&gt;Kubernetes Newwork 模式：IPVS&lt;/li&gt;
&lt;li&gt;Kubernetes Dashboard 版本：dashboard:v2.0.0-beta6&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>k8s进阶-架构-控制器</title>
    <link href="http://yoursite.com/2020/03/26/k8s%E8%BF%9B%E9%98%B6-%E6%9E%B6%E6%9E%84-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <id>http://yoursite.com/2020/03/26/k8s%E8%BF%9B%E9%98%B6-%E6%9E%B6%E6%9E%84-%E6%8E%A7%E5%88%B6%E5%99%A8/</id>
    <published>2020-03-26T08:49:58.000Z</published>
    <updated>2020-03-26T09:17:26.418Z</updated>
    
    <content type="html"><![CDATA[<p>控制器不断地尝试着将当前的状态调整到目标状态</p> <a id="more"></a> <h1 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h1><p>在 Kubernetes 中，<strong>控制器</strong> 就是上面所说的 <strong>控制循环</strong>，它不断监控着集群的状态，并对集群做出对应的变更调整。每一个控制器都不断地尝试着将 <strong><em>当前状态</em></strong> 调整到 <strong><em>目标状态</em></strong>。 </p><h2 id="控制器模式"><a href="#控制器模式" class="headerlink" title="控制器模式"></a>控制器模式</h2><p>在 Kubernetes 中，每个控制器至少追踪一种类型的资源。这些资源对象中有一个 <code>spec</code> 字段代表了目标状态。资源对象对应的控制器负责不断地将当前状态调整到目标状态。</p><p>理论上，控制器可以自己直接执行调整动作，然而，在Kubernetes 中，更普遍的做法是，控制器发送消息到 API Server，而不是直接自己执行调整动作。</p><h3 id="通过APIServer进行控制"><a href="#通过APIServer进行控制" class="headerlink" title="通过APIServer进行控制"></a>通过APIServer进行控制</h3><p>以 Kubernetes 中自带的一个控制器 Job Controller 为例。Kubernetes 自带的控制器都是通过与集群中 API Server 交互来达到调整状态的目的。</p><p>Job 是一种 Kubernetes API 对象，一个 Job 将运行一个（或多个）Pod，执行一项任务，然后停止。当新的 Job 对象被创建时，Job Controller 将确保集群中有合适数量的节点上的 kubelet 启动了指定个数的 Pod，以完成 Job 的执行任务。Job Controller 自己并不执行任何 Pod 或容器，而是发消息给 API Server，由其他的控制组件配合 API Server，以执行创建或删除 Pod 的实际动作。</p><p>当新的 Job 对象被创建时，目标状态是指定的任务被执行完成。Job Controller 调整集群的当前状态以达到目标状态：创建 Pod 以执行 Job 中指定的任务</p><p>控制器同样也会更新其关注的 API 对象。例如：一旦 Job 的任务执行结束，Job Controller 将更新 Job 的 API 对象，将其标注为 <code>Finished</code>。</p><h3 id="直接控制"><a href="#直接控制" class="headerlink" title="直接控制"></a>直接控制</h3><p>某些特殊的控制器需要对集群外部的东西做调整。例如，想用一个控制器确保集群中有足够的节点，此时控制器需要调用云供应商的接口以创建新的节点或移除旧的节点。这类控制器将从 API Server 中读取关于目标状态的信息，并直接调用外部接口以实现调整目标。</p><h2 id="目标状态-vs-当前状态"><a href="#目标状态-vs-当前状态" class="headerlink" title="目标状态 vs 当前状态"></a>目标状态 vs 当前状态</h2><p>Kubernetes 使用了 <code>云原生</code>（cloud-native）的视角来看待系统，并且可以持续应对变化。集群在运行的过程中，任何时候都有可能发生突发事件，而控制器则自动地修正这些问题。这就意味着，集群永远不会达到一个稳定不变的状态。</p><p>这种通过控制器监控集群状态并利用负反馈原理不断接近目标状态的系统，相较于那种完成安装后就不再改变的系统，是一种更高级的系统形态。</p><h2 id="运行控制器的方式"><a href="#运行控制器的方式" class="headerlink" title="运行控制器的方式"></a>运行控制器的方式</h2><p>Kubernetes 在 kube-controller-manager 中运行了大量的内建控制器（例如，Deployment Controller、Job Controller、StatefulSet Controller、DaemonSet Controller 等）。这些内建控制器提供了 Kubernetes 非常重要的核心功能。Kubernetes 可以运行一个 master 集群，以实现内建控制器的高可用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;控制器不断地尝试着将当前的状态调整到目标状态&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>k8s进阶-架构-集群内的通信</title>
    <link href="http://yoursite.com/2020/03/26/k8s%E8%BF%9B%E9%98%B6-%E6%9E%B6%E6%9E%84-%E9%9B%86%E7%BE%A4%E5%86%85%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2020/03/26/k8s%E8%BF%9B%E9%98%B6-%E6%9E%B6%E6%9E%84-%E9%9B%86%E7%BE%A4%E5%86%85%E7%9A%84%E9%80%9A%E4%BF%A1/</id>
    <published>2020-03-26T08:24:42.000Z</published>
    <updated>2020-03-27T07:24:09.675Z</updated>
    
    <content type="html"><![CDATA[<p> Master-Node之间的通信</p><a id="more"></a> <h1 id="Master-Node之间的通信"><a href="#Master-Node之间的通信" class="headerlink" title="Master-Node之间的通信"></a>Master-Node之间的通信</h1><p>Master-Node 之间的通信可以分为如下两类：</p><ul><li>Cluster to Master</li><li>Master to Cluster</li></ul><h2 id="Cluster-to-Master"><a href="#Cluster-to-Master" class="headerlink" title="Cluster to Master"></a>Cluster to Master</h2><p>所有从集群访问 Master 节点的通信，都是针对 apiserver 的（没有任何其他 master 组件发布远程调用接口）。通常安装 Kubernetes 时，apiserver 监听 HTTPS 端口（443），并且配置了一种或多种客户端认证方式 authentication。至少需要配置一种形式的授权方式 authorization，尤其是匿名访问 anonymous requests或 Service Account Tokens被启用的情况下。</p><p>节点上必须配置集群（apiserver）的公钥根证书（public root certificate），此时，在提供有效的客户端身份认证的情况下，节点可以安全地访问 APIServer。例如，在 Google Kubernetes Engine 的一个默认 Kubernetes 安装里，通过客户端证书为 kubelet 提供客户端身份认证。</p><p>对于需要调用 APIServer 接口的 Pod，应该为其关联 Service Account，此时，Kubernetes将在创建Pod时自动为其注入公钥根证书（public root certificate）以及一个有效的 bearer token（放在HTTP请求头Authorization字段）。所有名称空间中，都默认配置了名为 <code>kubernetes</code> Kubernetes Service，该 Service对应一个虚拟 IP（默认为 10.96.0.1），发送到该地址的请求将由 kube-proxy 转发到 apiserver 的 HTTPS 端口上。</p><p>默认情况下，从集群（节点以及节点上运行的 Pod）访问 master 的连接是安全的，因此，可以通过不受信的网络或公网连接 Kubernetes 集群</p><h2 id="Master-to-Cluster"><a href="#Master-to-Cluster" class="headerlink" title="Master to Cluster"></a>Master to Cluster</h2><p>从 master（apiserver）到Cluster存在着两条主要的通信路径：</p><ul><li>apiserver 访问集群中每个节点上的 kubelet 进程</li><li>使用 apiserver 的 proxy 功能，从 apiserver 访问集群中的任意节点、Pod、Service</li></ul><h3 id="apiserver-to-kubelet"><a href="#apiserver-to-kubelet" class="headerlink" title="apiserver to kubelet"></a>apiserver to kubelet</h3><p>apiserver 在如下情况下访问 kubelet：</p><ul><li>抓取 Pod 的日志</li><li>通过 <code>kubectl exec -it</code> 指令（或 kuboard 的终端界面）获得容器的命令行终端</li><li>提供 <code>kubectl port-forward</code> 功能</li></ul><p>这些连接的访问端点是 kubelet 的 HTTPS 端口。默认情况下，apiserver 不校验 kubelet 的 HTTPS 证书，这种情况下，连接可能会收到 man-in-the-middle 攻击，因此该连接如果在不受信网络或者公网上运行时，是 <strong>不安全</strong> 的。</p><p>如果要校验 kubelet 的 HTTPS 证书，可以通过 <code>--kubelet-certificate-authority</code> 参数为 apiserver 提供校验 kubelet 证书的根证书。</p><p>如果不能完成这个配置，又需要通过不受信网络或公网将节点加入集群，则需要使用SSH隧道连接 apiserver 和 kubelet。</p><p>同时，Kubelet authentication/authorization需要激活，以保护 kubelet API</p><h2 id="apiserver-to-nodes-pods-services"><a href="#apiserver-to-nodes-pods-services" class="headerlink" title="apiserver to nodes, pods, services"></a>apiserver to nodes, pods, services</h2><p>从 apiserver 到 节点/Pod/Service 的连接使用的是 HTTP 连接，没有进行身份认证，也没有进行加密传输。您也可以通过增加 <code>https</code> 作为 节点/Pod/Service 请求 URL 的前缀，但是 HTTPS 证书并不会被校验，也无需客户端身份认证，因此该连接是无法保证一致性的。目前，此类连接如果运行在非受信网络或公网上时，是 <strong>不安全</strong> 的</p><h2 id="SSH隧道"><a href="#SSH隧道" class="headerlink" title="SSH隧道"></a>SSH隧道</h2><p>Kubernetes 支持 SSH隧道（tunnel）来保护 Master –&gt; Cluster 访问路径。此时，apiserver 将向集群中的每一个节点建立一个 SSH隧道（连接到端口22的ssh服务）并通过隧道传递所有发向 kubelet、node、pod、service 的请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; Master-Node之间的通信&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>k8s进阶-架构-节点</title>
    <link href="http://yoursite.com/2020/03/26/k8s%E8%BF%9B%E9%98%B6-%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2020/03/26/k8s%E8%BF%9B%E9%98%B6-%E6%9E%B6%E6%9E%84/</id>
    <published>2020-03-26T02:21:12.000Z</published>
    <updated>2020-03-26T09:17:36.969Z</updated>
    
    <content type="html"><![CDATA[<p>节点  节点管理</p> <a id="more"></a> <h1 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h1><h2 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h2><p>节点的状态包含如下信息：</p><ul><li>Addresses</li><li>Conditions</li><li>Capacity and Allocatable</li><li>Info</li></ul><p>执行以下命令可查看所有节点的列表</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes -o wide</span><br></pre></td></tr></table></figure><p>执行以下命令可查看节点状态以及节点的其他详细信息： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node &lt;your-node-name&gt;</span><br></pre></td></tr></table></figure><h3 id="Addresses"><a href="#Addresses" class="headerlink" title="Addresses"></a>Addresses</h3><ul><li>HostName： 在节点命令行界面上执行 <code>hostname</code> 命令所获得的值。启动 kubelet 时，可以通过参数 <code>--hostname-override</code> 覆盖</li><li>ExternalIP：通常是节点的外部IP（可以从集群外访问的内网IP地址；上面的例子中，此字段为空）</li><li>InternalIP：通常是从节点内部可以访问的 IP 地址</li></ul><h3 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h3><p><code>Conditions</code> 描述了节点的状态。Condition的例子有：</p><table><thead><tr><th>Node Condition</th><th>描述</th></tr></thead><tbody><tr><td>OutOfDisk</td><td>如果节点上的空白磁盘空间不够，不能够再添加新的节点时，该字段为 <code>True</code>，其他情况为 <code>False</code></td></tr><tr><td>Ready</td><td>如果节点是健康的且已经就绪可以接受新的 Pod。则节点Ready字段为 <code>True</code>。<code>False</code>表明了该节点不健康，不能够接受新的 Pod。</td></tr><tr><td>MemoryPressure</td><td>如果节点内存紧张，则该字段为 <code>True</code>，否则为<code>False</code></td></tr><tr><td>PIDPressure</td><td>如果节点上进程过多，则该字段为 <code>True</code>，否则为 <code>False</code></td></tr><tr><td>DiskPressure</td><td>如果节点磁盘空间紧张，则该字段为 <code>True</code>，否则为 <code>False</code></td></tr><tr><td>NetworkUnvailable</td><td>如果节点的网络配置有问题，则该字段为 <code>True</code>，否则为 <code>False</code></td></tr></tbody></table><h3 id="Capacity-and-Allocatable（容量和可分配量）"><a href="#Capacity-and-Allocatable（容量和可分配量）" class="headerlink" title="Capacity and Allocatable（容量和可分配量）"></a>Capacity and Allocatable（容量和可分配量）</h3><p>容量和可分配量（Capacity and Allocatable）描述了节点上的可用资源的情况：</p><ul><li>CPU</li><li>内存</li><li>该节点可调度的最大 pod 数量</li></ul><p>Capacity 中的字段表示节点上的资源总数，Allocatable 中的字段表示该节点上可分配给普通 Pod 的资源总数。</p><h3 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h3><p>描述了节点的基本信息，例如：</p><ul><li>Linux 内核版本</li><li>Kubernetes 版本（kubelet 和 kube-proxy 的版本）</li><li>Docker 版本</li><li>操作系统名称</li></ul><p>这些信息由节点上的 kubelet 收集。</p><h1 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h1><p>与 Pod 和 Service 不一样，节点并不是由 Kubernetes 创建的，节点由云供应商（例如，Google Compute Engine、阿里云等）创建，或者节点已经存在于您的物理机/虚拟机的资源池。向 Kubernetes 中创建节点时，仅仅是创建了一个描述该节点的 API 对象。节点 API 对象创建成功后，Kubernetes将检查该节点是否有效。</p><h2 id="节点控制器（Node-Controller）"><a href="#节点控制器（Node-Controller）" class="headerlink" title="节点控制器（Node Controller）"></a>节点控制器（Node Controller）</h2><p>节点控制器是一个负责管理节点的 Kubernetes master 组件。在节点的生命周期中，节点控制器起到了许多作用。</p><ol><li>节点控制器在注册节点时为节点分配 CIDR 地址块</li><li>节点控制器通过云供应商（cloud-controller-manager）接口检查节点列表中每一个节点对象对应的虚拟机是否可用。在云环境中，只要节点状态异常，节点控制器检查其虚拟机在云供应商的状态，如果虚拟机不可用，自动将节点对象从 APIServer 中删除。</li><li>节点控制器监控节点的健康状况。当节点变得不可触达时（例如，由于节点已停机，节点控制器不再收到来自节点的心跳信号），节点控制器将节点API对象的 <code>NodeStatus</code> Condition 取值从 <code>NodeReady</code> 更新为 <code>Unknown</code>；然后在等待 <code>pod-eviction-timeout</code> 时间后，将节点上的所有 Pod 从节点驱逐。 </li></ol><blockquote><ul><li>默认40秒未收到心跳，修改 <code>NodeStatus</code> Condition 为 <code>Unknown</code>；</li><li>默认 <code>pod-eviction-timeout</code> 为 5分钟</li><li>节点控制器每隔 <code>--node-monitor-period</code> 秒检查一次节点的状态</li></ul></blockquote><h2 id="节点自注册（Self-Registration）"><a href="#节点自注册（Self-Registration）" class="headerlink" title="节点自注册（Self-Registration）"></a>节点自注册（Self-Registration）</h2><p>如果 kubelet 的启动参数 <code>--register-node</code>为 true（默认为 true），kubelet 会尝试将自己注册到 API Server。kubelet自行注册时，将使用如下选项：</p><ul><li><code>--kubeconfig</code>：向 apiserver 进行认证时所用身份信息的路径</li><li><code>--cloud-provider</code>：向云供应商读取节点自身元数据</li><li><code>--register-node</code>：自动向 API Server 注册节点</li><li><code>--register-with-taints</code>：注册节点时，为节点添加污点（逗号分隔，格式为 <key>=<value>:<effect></li><li><code>--node-ip</code>：节点的 IP 地址</li><li><code>--node-labels</code>：注册节点时，为节点添加标签</li><li><code>--node-status-update-frequency</code>：向 master 节点发送心跳信息的时间间隔</li></ul><p>如果 Node authorization mode 和 NodeRestriction admission plugin 被启用，kubelet 只拥有创建/修改其自身所对应的节点 API 对象的权限。</p><h2 id="手动管理节点"><a href="#手动管理节点" class="headerlink" title="手动管理节点"></a>手动管理节点</h2><p>如果想要手工创建节点API对象，可以将 kubelet 的启动参数 <code>--register-node</code> 设置为 false。</p><p>管理员可以修改节点API对象（不管是否设置了 <code>--register-node</code> 参数）。可以修改的内容有：</p><ul><li>增加/减少标签</li><li>标记节点为不可调度（unschedulable）</li></ul><p>节点的标签与 Pod 上的节点选择器（node selector）配合，可以控制调度方式，例如，限定 Pod 只能在某一组节点上运行。</p><p>执行如下命令可将节点标记为不可调度（unschedulable），此时将阻止新的 Pod 被调度到该节点上，但是不影响任何已经在该节点上运行的 Pod。这在准备重启节点之前非常有用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">cordon</span> <span class="string">$NODENAME</span></span><br></pre></td></tr></table></figure><h2 id="节点容量（Node-Capacity）"><a href="#节点容量（Node-Capacity）" class="headerlink" title="节点容量（Node Capacity）"></a>节点容量（Node Capacity）</h2><p>Kubernetes 调度器在调度 Pod 到节点上时，将确保节点上有足够的资源。具体来说，调度器检查节点上所有容器的资源请求之和不大于节点的容量。此时，只能检查由 kubelet 启动的容器，不包括直接由容器引擎启动的容器，更不包括不在容器里运行的进程</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;节点  节点管理&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>伸缩服务和滚动更新</title>
    <link href="http://yoursite.com/2020/03/25/%E4%BC%B8%E7%BC%A9%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/03/25/%E4%BC%B8%E7%BC%A9%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-03-25T08:43:30.000Z</published>
    <updated>2020-03-25T09:09:44.425Z</updated>
    
    <content type="html"><![CDATA[<p> 通过更改部署中的 replicas（副本数）来完成伸缩</p> <a id="more"></a>  <h2 id="Scaling（伸缩）应用程序"><a href="#Scaling（伸缩）应用程序" class="headerlink" title="Scaling（伸缩）应用程序"></a>Scaling（伸缩）应用程序</h2><p> <strong>伸缩</strong> 的实现可以通过更改 nginx-deployment.yaml 文件中部署的 replicas（副本数）来完成 </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">4</span>    <span class="comment">#使用该Deployment创建两个应用程序实例</span></span><br></pre></td></tr></table></figure><p>修改了 Deployment 的 replicas 为 4 后，Kubernetes 又为该 Deployment 创建了 3 新的 Pod，这 4 个 Pod 有相同的标签。因此Service A通过标签选择器与新的 Pod建立了对应关系，将访问流量通过负载均衡在 4 个 Pod 之间进行转发。 </p><p> <img src="https://kuboard.cn/assets/img/module_05_scaling2.3f74dfba.svg" alt="Kubernetes教程：伸缩"> </p><h2 id="将-nginx-Deployment-扩容到-4-个副本"><a href="#将-nginx-Deployment-扩容到-4-个副本" class="headerlink" title="将 nginx Deployment 扩容到 4 个副本"></a>将 nginx Deployment 扩容到 4 个副本</h2><p>修改 nginx-deployment.yaml 文件，将 replicas 修改为 4</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">4</span>     <span class="comment">#通过更改部署中的 replicas（副本数）来完成扩展</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看结果</span></span><br><span class="line">watch kubectl get pods -o wide</span><br></pre></td></tr></table></figure><h1 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h1><p>用户期望应用程序始终可用，为此开发者/运维者在更新应用程序时要分多次完成。在 Kubernetes 中，这是通过 Rolling Update 滚动更新完成的。<strong>Rolling Update滚动更新</strong> 通过使用新版本的 Pod 逐步替代旧版本的 Pod 来实现 Deployment 的更新，从而实现零停机。新的 Pod 将在具有可用资源的 Node（节点）上进行调度。</p><blockquote><p>Kubernetes 更新多副本的 Deployment 的版本时，会逐步的创建新版本的 Pod，逐步的停止旧版本的 Pod，以便使应用一直处于可用状态。这个过程中，Service 能够监视 Pod 的状态，将流量始终转发到可用的 Pod 上。</p></blockquote><h2 id="滚动更新步骤"><a href="#滚动更新步骤" class="headerlink" title="滚动更新步骤"></a>滚动更新步骤</h2><p>1.原本 Service A 将流量负载均衡到 4 个旧版本的 Pod （当中的容器为 绿色）上 </p><p> 1.原本 Service A 将流量负载均衡到 4 个旧版本的 Pod （当中的容器为 绿色）上 </p><p> <img src="https://kuboard.cn/assets/img/module_06_rollingupdates1.3f74dfba.svg" alt="Kubernetes教程：滚动更新1"> </p><p>2.更新完 Deployment 部署文件中的镜像版本后，master 节点选择了一个 worker 节点，并根据新的镜像版本创建 Pod（紫色容器）。新 Pod 拥有唯一的新的 IP。同时，master 节点选择一个旧版本的 Pod 将其移除。</p><p>此时，Service A 将新 Pod 纳入到负载均衡中，将旧Pod移除</p><p> <img src="https://kuboard.cn/assets/img/module_06_rollingupdates2.62afd5b1.svg" alt="Kubernetes教程：滚动更新2"> </p><ol start="3"><li><p>同步骤2，再创建一个新的 Pod 替换一个原有的 Pod  <img src="https://kuboard.cn/assets/img/module_06_rollingupdates3.dc3754d9.svg" alt="Kubernetes教程：滚动更新3"> </p></li><li><p>如此 Rolling Update 滚动更新，直到所有旧版本 Pod 均移除，新版本 Pod 也达到 Deployment 部署文件中定义的副本数，则滚动更新完成 </p><h2 id="更新-nginx-Deployment"><a href="#更新-nginx-Deployment" class="headerlink" title="更新 nginx Deployment"></a>更新 nginx Deployment</h2></li></ol><h6 id="修改-nginx-deployment-yaml-文件"><a href="#修改-nginx-deployment-yaml-文件" class="headerlink" title="修改 nginx-deployment.yaml 文件"></a><strong>修改 nginx-deployment.yaml 文件</strong></h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.8</span>   <span class="comment">#使用镜像nginx:1.8替换原来的nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看过程及结果，可观察到 pod 逐个被替换的过程。</span></span><br><span class="line">watch kubectl get pods -l app=nginx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 通过更改部署中的 replicas（副本数）来完成伸缩&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>Service服务</title>
    <link href="http://yoursite.com/2020/03/25/Service%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/03/25/Service%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-03-25T07:09:33.000Z</published>
    <updated>2020-03-25T08:29:26.546Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes Service（服务）概述</p> <a id="more"></a> <h2 id="Service（服务）概述"><a href="#Service（服务）概述" class="headerlink" title="Service（服务）概述"></a>Service（服务）概述</h2><p>Pod 有自己的生命周期。当 worker node（节点）故障时，节点上运行的 Pod（容器组）也会消失。然后，Deployment 可以通过创建新的 Pod（容器组）来动态地将群集调整回原来的状态，以使应用程序保持运行。 </p><h3 id="Service的作用："><a href="#Service的作用：" class="headerlink" title="Service的作用："></a>Service的作用：</h3><p>由于 Kubernetes 集群中每个 Pod（容器组）都有一个唯一的 IP 地址（即使是同一个 Node 上的不同 Pod），service 可以解决为前端系统屏蔽后端系统的 Pod（容器组）在销毁、创建过程中所带来的 IP 地址的变化。</p><p>Kubernetes 中的 <strong>Service（服务）</strong> 提供了这样的一个抽象层，它选择具备某些特征的 Pod（容器组）并为它们定义一个访问方式。Service（服务）使 Pod（容器组）之间的相互依赖解耦（原本从一个 Pod 中访问另外一个 Pod，需要知道对方的 IP 地址）。一个 Service（服务）选定哪些 <strong>Pod（容器组）</strong> 通常由 <strong>LabelSelector(标签选择器)</strong> 来决定。  </p><p>在创建Service的时候，通过设置配置文件中的 spec.type 字段的值，可以以不同方式向外部暴露应用程序： </p><ul><li><p><strong>ClusterIP</strong>（默认）</p><p>在群集中的内部IP上公布服务，这种方式的 Service（服务）只在集群内部可以访问到</p></li><li><p><strong>NodePort</strong></p><p>使用 NAT 在集群中每个的同一端口上公布服务。这种方式下，可以通过访问集群中任意节点+端口号的方式访问服务 <code>:</code>。此时 ClusterIP 的访问方式仍然可用。</p></li><li><p><strong>LoadBalancer</strong></p><p>在云环境中（需要云供应商可以支持）创建一个集群外部的负载均衡器，并为使用该负载均衡器的 IP 地址作为服务的访问地址。此时 ClusterIP 和 NodePort 的访问方式仍然可用。</p></li></ul><p>Service是一个抽象层，它通过 LabelSelector 选择了一组 Pod（容器组），把这些 Pod 的指定端口公布到到集群外部，并支持负载均衡和服务发现。</p><ul><li>公布 Pod 的端口以使其可访问</li><li>在多个 Pod 间实现负载均衡</li><li>使用 Label 和 LabelSelector</li></ul><h2 id="服务和标签"><a href="#服务和标签" class="headerlink" title="服务和标签"></a>服务和标签</h2><p> 下图中有两个服务Service A(黄色虚线)和Service B(蓝色虚线) Service A 将请求转发到 IP 为 10.10.10.1 的Pod上， Service B 将请求转发到 IP 为 10.10.10.2、10.10.10.3、10.10.10.4 的Pod上。 </p><p> <img src="https://kuboard.cn/assets/img/module_04_services.11cdc7bc.svg" alt="Kubernetes教程：服务和标签"> </p><p> Service 将外部请求路由到一组 Pod 中，它提供了一个抽象层，使得 Kubernetes 可以在不影响服务调用者的情况下，动态调度容器组 </p><p>Service使用 Labels、LabelSelector (标签和选择器 匹配一组 Pod。Labels（标签）是附加到 Kubernetes 对象的键/值对，其用途有多种：</p><ul><li>将 Kubernetes 对象（Node、Deployment、Pod、Service等）指派用于开发环境、测试环境或生产环境</li><li>嵌入版本标签，使用标签区别不同应用软件版本</li><li>使用标签对 Kubernetes 对象进行分类</li></ul><h3 id="Labels（标签）和-LabelSelector（标签选择器）之间的关联关系"><a href="#Labels（标签）和-LabelSelector（标签选择器）之间的关联关系" class="headerlink" title="Labels（标签）和 LabelSelector（标签选择器）之间的关联关系"></a>Labels（标签）和 LabelSelector（标签选择器）之间的关联关系</h3><ul><li><p>Deployment B 含有 LabelSelector 为 app=B 通过此方式声明含有 app=B 标签的 Pod 与之关联</p></li><li><p>通过 Deployment B 创建的 Pod 包含标签为 app=B</p></li><li><p>Service B 通过标签选择器 app=B 选择可以路由的 Pod</p><p><img src="https://kuboard.cn/assets/img/module_04_labels.3255e3d0.svg" alt="Kubernetes教程：服务和标签"> </p><p>Labels（标签）可以在创建 Kubernetes 对象时附加上去，也可以在创建之后再附加上去。任何时候都可以修改一个 Kubernetes 对象的 Labels（标签） </p></li></ul><h2 id="nginx-Deployment-创建一个-Service"><a href="#nginx-Deployment-创建一个-Service" class="headerlink" title="nginx Deployment 创建一个 Service"></a>nginx Deployment 创建一个 Service</h2><h6 id="创建nginx的Deployment中定义了Labels，如下："><a href="#创建nginx的Deployment中定义了Labels，如下：" class="headerlink" title="创建nginx的Deployment中定义了Labels，如下："></a>创建nginx的Deployment中定义了Labels，如下：</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span><span class="comment">#译名为元数据，即Deployment的一些基本属性和信息</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span><span class="comment">#Deployment的名称</span></span><br><span class="line">  <span class="attr">labels:</span><span class="comment">#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span><span class="comment">#为该Deployment设置key为app，value为nginx的标签</span></span><br></pre></td></tr></table></figure><h6 id="创建文件-nginx-service-yaml"><a href="#创建文件-nginx-service-yaml" class="headerlink" title="创建文件 nginx-service.yaml"></a><strong>创建文件 nginx-service.yaml</strong></h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span><span class="comment">#Service 的名称</span></span><br><span class="line">  <span class="attr">labels:</span>     <span class="comment">#Service 自己的标签</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span><span class="comment">#为该 Service 设置 key 为 app，value 为 nginx 的标签</span></span><br><span class="line"><span class="attr">spec:</span>    <span class="comment">#这是关于该 Service 的定义，描述了 Service 如何选择 Pod，如何被访问</span></span><br><span class="line">  <span class="attr">selector:</span>    <span class="comment">#标签选择器</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span><span class="comment">#选择包含标签 app:nginx 的 Pod</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span><span class="comment">#端口的名字</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span>    <span class="comment">#协议类型 TCP/UDP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span>        <span class="comment">#集群内的其他容器组可通过 80 端口访问 Service</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">32600</span>   <span class="comment">#通过任意节点的 32600 端口访问 Service</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span><span class="comment">#将请求转发到匹配 Pod 的 80 端口</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span><span class="comment">#Serive的类型，ClusterIP/NodePort/LoaderBalancer</span></span><br></pre></td></tr></table></figure><p><strong>执行命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-service.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查执行结果</span></span><br><span class="line">kubectl get services -o wide   <span class="comment">#可查看到名称为 nginx-service 的服务。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#访问服务</span></span><br><span class="line">curl &lt;任意节点的 IP&gt;:32600</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes Service（服务）概述&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>查看Pods/Nodes</title>
    <link href="http://yoursite.com/2020/03/25/%E6%9F%A5%E7%9C%8BPods-Nodes/"/>
    <id>http://yoursite.com/2020/03/25/%E6%9F%A5%E7%9C%8BPods-Nodes/</id>
    <published>2020-03-25T06:05:21.000Z</published>
    <updated>2020-03-25T06:21:04.946Z</updated>
    
    <content type="html"><![CDATA[<p>了解 Pod 和 Node</p> <a id="more"></a> <h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>​    Pod中的容器共享 IP 地址和端口空间（同一 Pod 中的不同 container 端口不能相互冲突），始终位于同一位置并共同调度，并在同一节点上的共享上下文中运行。（同一个Pod内的容器可以localhost + 端口互相访问）。 </p><p>​    当在 k8s 上创建 Deployment 时，会在集群上创建包含容器的 Pod (而不是直接创建容器)。每个Pod都与运行它的 worker 节点（Node）绑定，并保持在那里直到终止或被删除。如果节点（Node）发生故障，则会在群集中的其他可用节点（Node）上运行相同的 Pod（从同样的镜像创建 Container，使用同样的配置，IP 地址不同，Pod 名字不同）。 </p><ul><li>Pod（容器组）是 k8s 集群上的最基本的单元。</li><li>Pod 是一组容器（可包含一个或多个应用程序容器），以及共享存储（卷 Volumes）、IP 地址和有关如何运行容器的信息。 </li><li>如果多个容器紧密耦合并且需要共享磁盘等资源，则应该被部署在同一个Pod（容器组）中 </li></ul><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p> <img src="https://kuboard.cn/assets/img/module_03_nodes.38f0ef71.svg" alt="Kubernetes教程：Node概念"> </p><ol><li>Pod（容器组）总是在 <strong>Node（节点）</strong> 上运行。</li><li>Node（节点）是 kubernetes 集群中的计算机，可以是虚拟机或物理机。</li><li>每个 Node（节点）都由 master 管理。</li><li>一个 Node（节点）可以有多个Pod（容器组），kubernetes master 会根据每个 Node（节点）上可用资源的情况，自动调度 Pod（容器组）到最佳的 Node（节点）上。</li></ol><h6 id="每个Node（节点）至少运行："><a href="#每个Node（节点）至少运行：" class="headerlink" title="每个Node（节点）至少运行："></a>每个Node（节点）至少运行：</h6><ul><li>Kubelet，负责 master 节点和 worker 节点之间通信的进程；管理 Pod（容器组）和 Pod（容器组）内运行的 Container（容器）。</li><li>容器运行环境（如Docker）负责下载镜像、创建和运行容器等。</li></ul><h2 id="相关命令操作"><a href="#相关命令操作" class="headerlink" title="相关命令操作"></a>相关命令操作</h2><h6 id="kubectl-get-显示资源列表"><a href="#kubectl-get-显示资源列表" class="headerlink" title="kubectl get - 显示资源列表"></a><strong>kubectl get</strong> - 显示资源列表</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get 资源类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取类型为Deployment的资源列表</span></span><br><span class="line">kubectl get deployments</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取类型为Pod的资源列表</span></span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取类型为Node的资源列表</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有名称空间的 Deployment</span></span><br><span class="line">kubectl get deployments -A</span><br><span class="line">kubectl get deployments --all-namespaces</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 kube-system 名称空间的 Deployment</span></span><br><span class="line">kubectl get deployments -n kube-system</span><br></pre></td></tr></table></figure><h6 id="kubectl-describe-显示有关资源的详细信息"><a href="#kubectl-describe-显示有关资源的详细信息" class="headerlink" title="kubectl describe - 显示有关资源的详细信息"></a><strong>kubectl describe</strong> - 显示有关资源的详细信息</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl describe 资源类型 资源名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看名称为nginx-XXXXXX的Pod的信息</span></span><br><span class="line">kubectl describe pod nginx-XXXXXX</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看名称为nginx的Deployment的信息</span></span><br><span class="line">kubectl describe deployment nginx</span><br></pre></td></tr></table></figure><h6 id="kubectl-logs-查看pod中的容器的打印日志（和命令docker-logs-类似）"><a href="#kubectl-logs-查看pod中的容器的打印日志（和命令docker-logs-类似）" class="headerlink" title="kubectl logs - 查看pod中的容器的打印日志（和命令docker logs 类似）"></a><strong>kubectl logs</strong> - 查看pod中的容器的打印日志（和命令docker logs 类似）</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl logs Pod名称</span></span><br><span class="line">kubectl logs -f nginx-pod-XXXXXXX</span><br></pre></td></tr></table></figure><h6 id="kubectl-exec-在pod中的容器环境内执行命令-和命令docker-exec-类似"><a href="#kubectl-exec-在pod中的容器环境内执行命令-和命令docker-exec-类似" class="headerlink" title="kubectl exec - 在pod中的容器环境内执行命令(和命令docker exec 类似)"></a><strong>kubectl exec</strong> - 在pod中的容器环境内执行命令(和命令docker exec 类似)</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl exec Pod名称 操作命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在名称为nginx-pod-xxxxxx的Pod中运行bash</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx-pod-xxxxxx /bin/bash</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 Pod 和 Node&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>k8s部署一个应用程序</title>
    <link href="http://yoursite.com/2020/03/25/k8s%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/03/25/k8s%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-03-25T05:49:00.000Z</published>
    <updated>2020-03-25T05:59:21.447Z</updated>
    
    <content type="html"><![CDATA[<p> 使用 kubectl 在 k8s 上部署第一个应用程序。 </p> <a id="more"></a> <h2 id="Deployment概念"><a href="#Deployment概念" class="headerlink" title="Deployment概念"></a>Deployment概念</h2><p>​    通过发布 Deployment，可以创建应用程序 (docker image) 的实例 (docker container)，这个实例会被包含在称为 <strong>Pod</strong> 的概念中，<strong>Pod</strong> 是 k8s 中最小可管理单元。</p><p>​    在 k8s 集群中发布 Deployment 后，Deployment 将指示 k8s 如何创建和更新应用程序的实例，master 节点将应用程序实例调度到集群中的具体的节点上。</p><p>​    创建应用程序实例后，Kubernetes Deployment Controller 会持续监控这些实例。如果运行实例的 worker 节点关机或被删除，则 Kubernetes Deployment Controller 将在群集中资源最优的另一个 worker 节点上重新创建一个新的实例。<strong>这提供了一种自我修复机制来解决机器故障或维护问题。</strong></p><p>​    通过创建应用程序实例并确保它们在集群节点中的运行实例个数，Kubernetes Deployment 提供了一种完全不同的方式来管理应用程序。</p><p> <img src="https://kuboard.cn/assets/img/module_02_first_app.25e902c4.svg" alt="Kubernetes教程：部署第一个应用程序"> </p><p> Deployment 处于 master 节点上，通过发布 Deployment，master 节点会选择合适的 worker 节点创建 Container（即图中的正方体），Container 会被包含在 Pod （即蓝色圆圈）里。 </p><h2 id="部署-nginx-Deployment"><a href="#部署-nginx-Deployment" class="headerlink" title="部署 nginx Deployment"></a>部署 nginx Deployment</h2><h6 id="创建文件-nginx-deployment-yaml"><a href="#创建文件-nginx-deployment-yaml" class="headerlink" title="创建文件 nginx-deployment.yaml"></a>创建文件 nginx-deployment.yaml</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span><span class="comment">#与k8s集群版本有关，使用 kubectl api-versions 即可查看当前集群支持的版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span><span class="comment">#该配置的类型，我们使用的是 Deployment</span></span><br><span class="line"><span class="attr">metadata:</span>        <span class="comment">#译名为元数据，即 Deployment 的一些基本属性和信息</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span><span class="comment">#Deployment 的名称</span></span><br><span class="line">  <span class="attr">labels:</span>    <span class="comment">#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组，目前不需要理解</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span><span class="comment">#为该Deployment设置key为app，value为nginx的标签</span></span><br><span class="line"><span class="attr">spec:</span>        <span class="comment">#这是关于该Deployment的描述，可以理解为你期待该Deployment在k8s中如何使用</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span><span class="comment">#使用该Deployment创建一个应用程序实例</span></span><br><span class="line">  <span class="attr">selector:</span>    <span class="comment">#标签选择器，与上面的标签共同作用，目前不需要理解</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment">#选择包含标签app:nginx的资源</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span>    <span class="comment">#这是选择或创建的Pod的模板</span></span><br><span class="line">    <span class="attr">metadata:</span><span class="comment">#Pod的元数据</span></span><br><span class="line">      <span class="attr">labels:</span><span class="comment">#Pod的标签，上面的selector即选择包含标签app:nginx的Pod</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span>    <span class="comment">#期望Pod实现的功能（即在pod中部署）</span></span><br><span class="line">      <span class="attr">containers:</span><span class="comment">#生成container，与docker中的container是同一种</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span><span class="comment">#container的名称</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span><span class="comment">#使用镜像nginx:1.7.9创建container，该container默认80端口可访问</span></span><br></pre></td></tr></table></figure><h6 id="应用-YAML-文件"><a href="#应用-YAML-文件" class="headerlink" title="应用 YAML 文件"></a><strong>应用 YAML 文件</strong></h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure><h6 id="查看部署结果"><a href="#查看部署结果" class="headerlink" title="查看部署结果"></a><strong>查看部署结果</strong></h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Deployment</span></span><br><span class="line">kubectl get deployments</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod</span></span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 使用 kubectl 在 k8s 上部署第一个应用程序。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>kubectl 命令技巧大全</title>
    <link href="http://yoursite.com/2020/03/20/kubectl%20%E5%91%BD%E4%BB%A4%E6%8A%80%E5%B7%A7%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2020/03/20/kubectl%20%E5%91%BD%E4%BB%A4%E6%8A%80%E5%B7%A7%E5%A4%A7%E5%85%A8/</id>
    <published>2020-03-20T03:13:20.000Z</published>
    <updated>2020-03-20T07:20:09.424Z</updated>
    
    <content type="html"><![CDATA[<p>一些基本的kubernets操作命令</p> <a id="more"></a> <h1 id="kubectl-命令技巧大全"><a href="#kubectl-命令技巧大全" class="headerlink" title="kubectl 命令技巧大全"></a><strong>kubectl 命令技巧大全</strong></h1><h2 id="Kubectl-自动补全"><a href="#Kubectl-自动补全" class="headerlink" title="Kubectl 自动补全"></a><strong>Kubectl 自动补全</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install -y bash-completion</span><br><span class="line"></span><br><span class="line">source &#x2F;usr&#x2F;share&#x2F;bash-completion&#x2F;bash_completion</span><br><span class="line"></span><br><span class="line">source &lt;(kubectl completion bash)</span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a><strong>创建对象</strong></h2><p>Kubernetes 的清单文件可以使用 json 或 yaml 格式定义。可以以 .yaml、.yml、或者 .json 为扩展名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f .&#x2F;my-manifest.yaml           # 创建资源</span><br><span class="line"></span><br><span class="line">$ kubectl create -f .&#x2F;my1.yaml -f .&#x2F;my2.yaml     # 使用多个文件创建资源</span><br><span class="line"></span><br><span class="line">$ kubectl create -f .&#x2F;dir                        # 使用目录下的所有清单文件来创建资源</span><br><span class="line"></span><br><span class="line">$ kubectl create -f https:&#x2F;&#x2F;git.io&#x2F;vPieo         # 使用 url 来创建资源</span><br><span class="line"></span><br><span class="line">$ kubectl run nginx --image&#x3D;nginx                # 启动一个 nginx 实例</span><br><span class="line"></span><br><span class="line">$ kubectl explain pods,svc                       # 获取 pod 和 svc 的文档</span><br></pre></td></tr></table></figure><h2 id="显示和查找资源"><a href="#显示和查找资源" class="headerlink" title="显示和查找资源"></a><strong>显示和查找资源</strong></h2><p> 列出所有 namespace 中的所有service </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get services</span><br></pre></td></tr></table></figure><p>列出所有 namespace 中的所有 pod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --all-namespaces</span><br></pre></td></tr></table></figure><p> 列出所有 pod 并显示详细信息 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -o wide</span><br></pre></td></tr></table></figure><p> 列出指定 deployment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deployment my-dep</span><br></pre></td></tr></table></figure><p> 列出该 namespace 中的所有 pod 包括未初始化的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --include-uninitialized</span><br></pre></td></tr></table></figure><p>使用详细输出来描述命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> $ kubectl describe nodes my-node </span><br><span class="line"></span><br><span class="line">$ kubectl describe pods my-pod </span><br><span class="line"></span><br><span class="line">$ kubectl get services --sort-by&#x3D;.metadata.name</span><br></pre></td></tr></table></figure><p> 根据重启次数排序列出 pod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --sort-by&#x3D;&#39;.status.containerStatuses[0].restartCount&#39;</span><br></pre></td></tr></table></figure><p>获取所有具有 app=cassandra 的 pod 中的 version 标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --selector&#x3D;app&#x3D;cassandra rc -o \  jsonpath&#x3D;&#39;&#123;.items[*].metadata.labels.version&#125;&#39;</span><br></pre></td></tr></table></figure><p> 获取所有节点的 ExternalIP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes -o jsonpath&#x3D;&#39;&#123;.items[*].status.addresses[?(@.type&#x3D;&#x3D;&quot;ExternalIP&quot;)].address&#125;&#39;</span><br></pre></td></tr></table></figure><p>列出属于某个 PC 的 Pod 的名字，“jq”命令用于转换复杂的 jsonpath，参考 <a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">https://stedolan.github.io/jq/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> $ sel&#x3D;$&#123;$(kubectl get rc my-rc --output&#x3D;json | jq -j &#39;.spec.selector | to_entries | .[] | &quot;\(.key)&#x3D;\(.value),&quot;&#39;)%?&#125; </span><br><span class="line"></span><br><span class="line">$ echo $(kubectl get pods --selector&#x3D;$sel --output&#x3D;jsonpath&#x3D;&#123;.items..metadata.name&#125;)</span><br></pre></td></tr></table></figure><p>查看哪些节点已就绪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ JSONPATH&#x3D;&#39;&#123;range .items[*]&#125;&#123;@.metadata.name&#125;:&#123;range @.status.conditions[*]&#125;&#123;@.type&#125;&#x3D;&#123;@.status&#125;;&#123;end&#125;&#123;end&#125;&#39; \ &amp;&amp; kubectl get nodes -o jsonpath&#x3D;&quot;$JSONPATH&quot; | grep &quot;Ready&#x3D;True&quot;</span><br></pre></td></tr></table></figure><p> 列出当前 Pod 中使用的 Secret</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -o json | jq &#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39; | grep -v null | sort | uniq</span><br></pre></td></tr></table></figure><h2 id="更新资源"><a href="#更新资源" class="headerlink" title="更新资源"></a><strong>更新资源</strong></h2><p>滚动更新 pod frontend-v1 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rolling-update frontend-v1 -f frontend-v2.json</span><br></pre></td></tr></table></figure><p>更新资源名称并更新镜像            </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rolling-update frontend-v1 frontend-v2 --image&#x3D;image:v2</span><br></pre></td></tr></table></figure><p>更新 frontend pod 中的镜像 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rolling-update frontend --image&#x3D;image:v2</span><br></pre></td></tr></table></figure><p>退出已存在的进行中的滚动更新                  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rolling-update frontend-v1 frontend-v2 --rollback</span><br></pre></td></tr></table></figure><p>基于 stdin 输入的 JSON 替换 pod </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat pod.json | kubectl replace -f -</span><br></pre></td></tr></table></figure><p>强制替换，删除后重新创建资源。会导致服务中断。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl replace --force -f .&#x2F;pod.json</span><br></pre></td></tr></table></figure><p>为 nginx RC 创建服务，启用本地 80 端口连接到容器上的 8000 端口 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl expose rc nginx --port&#x3D;80 --target-port&#x3D;8000</span><br></pre></td></tr></table></figure><p>更新单容器 pod 的镜像版本（tag）到 v4 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod mypod -o yaml | sed &#39;s&#x2F;\(image: myimage\):.*$&#x2F;\1:v4&#x2F;&#39; | kubectl replace -f -</span><br></pre></td></tr></table></figure><p>添加标签 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl label pods my-pod new-label&#x3D;awesome</span><br></pre></td></tr></table></figure><p>添加注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl annotate pods my-pod icon-url&#x3D;http:&#x2F;&#x2F;goo.gl&#x2F;XXBTWq</span><br></pre></td></tr></table></figure><p>自动扩展 deployment “foo”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl autoscale deployment foo --min&#x3D;2 --max&#x3D;10</span><br></pre></td></tr></table></figure><h2 id="删除资源"><a href="#删除资源" class="headerlink" title="删除资源"></a><strong>删除资源</strong></h2><p># 删除 pod.json 文件中定义的类型和名称的 pod </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f .&#x2F;pod.json</span><br></pre></td></tr></table></figure><p>删除名为“baz”的 pod 和名为“foo”的 service </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pod,service baz foo</span><br></pre></td></tr></table></figure><p>删除具有 name=myLabel 标签的 pod 和 serivce </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pods,services -l name&#x3D;myLabel</span><br></pre></td></tr></table></figure><p>删除具有 name=myLabel 标签的 pod 和 service，包括尚未初始化的 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pods,services -l name&#x3D;myLabel --include-uninitialized</span><br></pre></td></tr></table></figure><p>删除 my-ns namespace 下的所有 pod 和 serivce，包括尚未初始化的  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n my-ns delete po,svc --all</span><br></pre></td></tr></table></figure><h2 id="与运行中的Pod交互"><a href="#与运行中的Pod交互" class="headerlink" title="与运行中的Pod交互"></a><strong>与运行中的Pod交互</strong></h2><p># dump 输出 pod 的日志（stdout） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs my-pod</span><br></pre></td></tr></table></figure><p>dump 输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs my-pod -c my-container</span><br></pre></td></tr></table></figure><p>流式输出 pod 的日志（stdout） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs -f my-pod</span><br></pre></td></tr></table></figure><p>流式输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs -f my-pod -c my-container</span><br></pre></td></tr></table></figure><p>交互式 shell 的方式运行 pod </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run -i --tty busybox --image&#x3D;busybox -- sh</span><br></pre></td></tr></table></figure><p>连接到运行中的容器   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl attach my-pod -i</span><br></pre></td></tr></table></figure><p>转发 pod 中的 6000 端口到本地的 5000 端口 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl port-forward my-pod 5000:6000</span><br></pre></td></tr></table></figure><p>在已存在的容器中执行命令（只有一个容器的情况下） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl exec my-pod -- ls &#x2F;</span><br></pre></td></tr></table></figure><p>在已存在的容器中执行命令（pod 中有多个容器的情况下） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl exec my-pod -c my-container -- ls &#x2F;</span><br></pre></td></tr></table></figure><p>显示指定 pod 和容器的指标度量    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl top pod POD_NAME --containers</span><br></pre></td></tr></table></figure><h2 id="与节点和集群交互"><a href="#与节点和集群交互" class="headerlink" title="与节点和集群交互"></a><strong>与节点和集群交互</strong></h2><p># 标记 my-node 不可调度 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cordon my-node</span><br></pre></td></tr></table></figure><p>清空 my-node 以待维护 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl drain my-node</span><br></pre></td></tr></table></figure><p>标记 my-node 可调度 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl uncordon my-node</span><br></pre></td></tr></table></figure><p>显示 my-node 的指标度量 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl top node my-node</span><br></pre></td></tr></table></figure><p>显示 master 和服务的地址 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cluster-info</span><br></pre></td></tr></table></figure><p>将当前集群状态输出到 stdout </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cluster-info dump</span><br></pre></td></tr></table></figure><p>将当前集群状态输出到 /path/to/cluster-state </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cluster-info dump --output-directory&#x3D;&#x2F;path&#x2F;to&#x2F;cluster-state</span><br></pre></td></tr></table></figure><p>如果该键和影响的污点（taint）已存在，则使用指定的值替换 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl taint nodes foo dedicated&#x3D;special-user:NoSchedule</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>资源类型</strong></th><th><strong>缩写别名</strong></th></tr></thead><tbody><tr><td>clusters</td><td></td></tr><tr><td>componentstatuses</td><td>cs</td></tr><tr><td>configmaps</td><td>cm</td></tr><tr><td>daemonsets</td><td>ds</td></tr><tr><td>deployments</td><td>deploy</td></tr><tr><td>endpoints</td><td>ep</td></tr><tr><td>event</td><td>ev</td></tr><tr><td>horizontalpodautoscalers</td><td>hpa</td></tr><tr><td>ingresses</td><td>ing</td></tr><tr><td>jobs</td><td></td></tr><tr><td>limitranges</td><td>limits</td></tr><tr><td>namespaces</td><td>ns</td></tr><tr><td>networkpolicies</td><td></td></tr><tr><td>nodes</td><td>no</td></tr><tr><td>statefulsets</td><td></td></tr><tr><td>persistentvolumeclaims</td><td>pvc</td></tr><tr><td>persistentvolumes</td><td>pv</td></tr><tr><td>pods</td><td>po</td></tr><tr><td>podsecuritypolicies</td><td>psp</td></tr><tr><td>podtemplates</td><td></td></tr><tr><td>replicasets</td><td>rs</td></tr><tr><td>replicationcontrollers</td><td>rc</td></tr><tr><td>resourcequotas</td><td>quota</td></tr><tr><td>cronjob</td><td></td></tr><tr><td>secrets</td><td></td></tr><tr><td>serviceaccount</td><td>sa</td></tr><tr><td>services</td><td>svc</td></tr><tr><td>storageclasses</td><td></td></tr></tbody></table><h2 id="kubectl-get-显示资源列表"><a href="#kubectl-get-显示资源列表" class="headerlink" title="kubectl get - 显示资源列表"></a>kubectl get - 显示资源列表</h2><p>#获取类型为Deployment的资源列表 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments</span><br></pre></td></tr></table></figure><p>#获取类型为Pod的资源列表 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>#获取类型为Node的资源列表 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><p>在命令后增加 -A 或 –all-namespaces 可查看所有名称空间中的对象，使用参数 -n 可查看指定名称空间的对象，例如</p><p># 查看所有名称空间的 Deployment </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments -A </span><br><span class="line">kubectl get deployments --all-namespaces</span><br></pre></td></tr></table></figure><p>查看 kube-system 名称空间的 Deployment </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments -n kube-system</span><br></pre></td></tr></table></figure><p>检查 kubectl 是否知道集群地址及凭证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl config view</span><br></pre></td></tr></table></figure><p>通过 kubectl cluster-info 命令获得这些服务列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ebs ~]# kubectl cluster-info </span><br><span class="line"></span><br><span class="line">Kubernetes master is running at https:&#x2F;&#x2F;172.16.121.88:6443 KubeDNS is running at https:&#x2F;&#x2F;172.16.121.88:6443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;kube-system&#x2F;services&#x2F;kube-dns:dns&#x2F;proxy </span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use &#39;kubectl cluster-info dump&#39;.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些基本的kubernets操作命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>Kubernetes核心概念</title>
    <link href="http://yoursite.com/2020/03/20/Kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2020/03/20/Kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</id>
    <published>2020-03-20T03:10:20.000Z</published>
    <updated>2020-03-25T09:26:08.403Z</updated>
    
    <content type="html"><![CDATA[<p>Cluster，Pod，Label， Replication Controller ，Service …</p> <a id="more"></a> <h2 id="什么是Kubernetes？"><a href="#什么是Kubernetes？" class="headerlink" title="什么是Kubernetes？"></a>什么是Kubernetes？</h2><p>Kubernetes（k8s）是自动化容器操作的开源平台，这些操作包括部署，调度和节点集群间扩展。如果你曾经用过Docker容器技术部署容器，那么可以将Docker看成Kubernetes内部使用的低级别组件。Kubernetes不仅仅支持Docker，还支持Rocket，这是另一种容器技术。 使用Kubernetes可以：</p><ul><li>自动化容器的部署和复制</li><li>随时扩展或收缩容器规模</li><li>将容器组织成组，并且提供容器间的负载均衡</li><li>很容易地升级应用程序容器的新版本</li><li>提供容器弹性，如果容器失效就替换它，等等…</li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>集群是一组节点，这些节点可以是物理服务器或者虚拟机，之上安装了Kubernetes平台。下图展示这样的集群。注意该图为了强调核心概念有所简化。这里可以看到一个典型的Kubernetes架构图。</p><p><img src="https://kuboard.cn/assets/img/d7ce07842371eab180725bab5164ec17.d58ea9cc.png" alt="Kubernetes教程：Kubernetes核心概念-集群"></p><p>上图可以看到如下组件，使用特别的图标表示Service和Label：</p><ul><li>PodContainer（容器）</li><li>Labe （标签）</li><li>Replication Controller（复制控制器）</li><li>Service（服务）</li><li>Node（节点）</li><li>Kubernetes Master（Kubernetes主节点）</li></ul><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Pod（上图绿色方框）安排在节点上，包含一组容器和卷。同一个Pod里的容器共享同一个网络命名空间，可以使用localhost互相通信。Pod是短暂的，不是持续性实体。你可能会有这些问题：</p><ul><li>如果Pod是短暂的，那么我怎么才能持久化容器数据使其能够跨重启而存在呢？ 是的，Kubernetes支持 <strong><em>卷</em></strong> 的概念，因此可以使用持久化的卷类型。</li><li>是否手动创建Pod，如果想要创建同一个容器的多份拷贝，需要一个个分别创建出来么？可以手动创建单个Pod，但是也可以使用Replication Controller使用Pod模板创建出多份拷贝，下文会详细介绍。</li><li>如果Pod是短暂的，那么重启时IP地址可能会改变，那么怎么才能从前端容器正确可靠地指向后台容器呢？这时可以使用Service，下文会详细介绍。</li></ul><h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>正如图所示，一些Pod有Label 。一个Label是attach到Pod的一对键/值对，用来传递用户定义的属性。比如，你可能创建了一个”tier”和“app”标签，通过Label（<strong>tier=frontend, app=myapp</strong>）来标记前端Pod容器，使用Label（<strong>tier=backend, app=myapp</strong>）标记后台Pod。然后可以使用 [Selectors] 选择带有特定Label的Pod，并且将Service或者Replication Controller应用到上面。</p><h2 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h2><p><em>是否手动创建Pod，如果想要创建同一个容器的多份拷贝，需要一个个分别创建出来么，能否将Pods划到逻辑组里？</em></p><p>Replication Controller确保任意时间都有指定数量的Pod“副本”在运行。如果为某个Pod创建了Replication Controller并且指定3个副本，它会创建3个Pod，并且持续监控它们。如果某个Pod不响应，那么Replication Controller会替换它，保持总数为3.如下面的动画所示：</p><p><img src="https://kuboard.cn/assets/img/03d07039d9fc80c0f692d6176f65936e.7af9fab5.gif" alt="Kubernetes教程：Kubernetes核心概念-Replication Controller"></p><p>如果之前不响应的Pod恢复了，现在就有4个Pod了，那么Replication Controller会将其中一个终止保持总数为3。如果在运行中将副本总数改为5，Replication Controller会立刻启动2个新Pod，保证总数为5。还可以按照这样的方式缩小Pod，这个特性在执行滚动 [升级] 时很有用。</p><p>当创建Replication Controller时，需要指定两个东西：</p><ol><li>Pod模板：用来创建Pod副本的模板</li><li>Label：Replication Controller需要监控的Pod的标签。现在已经创建了Pod的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是Service。</li></ol><p>TIP</p><p>最新 Kubernetes 版本里，推荐使用 Deployment</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p><em>如果Pods是短暂的，那么重启时IP地址可能会改变，怎么才能从前端容器正确可靠地指向后台容器呢？</em> [Service] <strong>抽象</strong> 现在，假定有2个后台Pod，并且定义后台Service的名称为‘backend-service’，label选择器为(tier=backend, app=myapp) 的Service会完成如下两件重要的事情：</p><ul><li>会为Service创建一个本地集群的DNS入口，因此前端Pod只需要DNS查找主机名为 ‘backend-service’，就能够解析出前端应用程序可用的IP地址。</li><li>现在前端已经得到了后台服务的IP地址，但是它应该访问2个后台Pod的哪一个呢？Service在这2个后台Pod之间提供透明的负载均衡，会将请求分发给其中的任意一个（如下面的动画所示）。通过每个Node上运行的代理（kube-proxy）完成。</li></ul><p>下述动画展示了Service的功能。注意该图作了很多简化。如果不进入网络配置，那么达到透明的负载均衡目标所涉及的底层网络和路由相对先进。如果有兴趣，有更深入的介绍。</p><p><img src="https://kuboard.cn/assets/img/e7a273fcdc03d2417b354b60c253552f.19ae82d9.gif" alt="Kubernetes教程：Kubernetes核心概念-Service"></p><p>每个节点都运行如下Kubernetes关键组件：</p><ul><li>Kubelet：是主节点代理。</li><li>Kube-proxy：Service使用其将链接路由到Pod，如上文所述。</li><li>Docker或Rocket：Kubernetes使用的容器技术来创建容器。</li></ul><h3 id="Kubernetes-Master"><a href="#Kubernetes-Master" class="headerlink" title="Kubernetes Master"></a>Kubernetes Master</h3><p>集群拥有一个Kubernetes Master（紫色方框）。Kubernetes Master提供集群的独特视角，并且拥有一系列组件，比如Kubernetes API Server。API Server提供可以用来和集群交互的REST端点。master节点包括用来创建和复制Pod的Replication Controller。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cluster，Pod，Label， Replication Controller ，Service …&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo 使用</title>
    <link href="http://yoursite.com/2020/03/19/hexo%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/03/19/hexo%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-19T09:18:36.000Z</published>
    <updated>2020-03-23T07:14:57.409Z</updated>
    
    <content type="html"><![CDATA[<p>hexo 搭建、部署、操作；</p> <a id="more"></a> <p>_config.yml配置git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:  </span><br><span class="line">  type: &#39;git&#39;  </span><br><span class="line">  repo: git@github.com:yourname&#x2F;yourname.github.io.git  </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h5 id="上传github，推送文件步骤："><a href="#上传github，推送文件步骤：" class="headerlink" title="上传github，推送文件步骤："></a>上传github，推送文件步骤：</h5><p>hexo clean      hexo c   清除缓存文件 (db.json) 和已生成的静态文件 (public) </p><p>hexo generate   hexo g   生成静态文件 </p><p>hexo deploy     hexo d   部署网站 </p><p>执行端口启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -i 0.0.0.0 -p 8080</span><br></pre></td></tr></table></figure><p>绑定个人域名：</p><p>解析域名注意，博客网址中必须使用你github的用户名.</p><p><strong>布局（Layout）</strong></p><p>Hexo 有三种默认布局：post、page 和 draft。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td>post</td><td>source/_posts</td></tr><tr><td>page</td><td>source</td></tr><tr><td>draft</td><td>source/_drafts</td></tr></tbody></table><p><strong>hexo init</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init [ folder]</span><br></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><p><strong>hexo new</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><p>hexo new “post title with whitespace” </p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p, –path</td><td>自定义新文章的路径</td></tr><tr><td>-r, –replace</td><td>如果存在同名文章，将其替换</td></tr><tr><td>-s, –slug</td><td>文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br></pre></td></tr></table></figure><p>以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 “About me”</p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me</span><br></pre></td></tr></table></figure><p>此时 Hexo 会创建 source/_posts/about/me.md，同时 me.md 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo 搭建、部署、操作；&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
</feed>
