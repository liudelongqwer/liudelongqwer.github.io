<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拒绝再玩</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-25T09:09:44.425Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>duoyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>伸缩服务和滚动更新</title>
    <link href="http://yoursite.com/2020/03/25/%E4%BC%B8%E7%BC%A9%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/03/25/%E4%BC%B8%E7%BC%A9%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-03-25T08:43:30.000Z</published>
    <updated>2020-03-25T09:09:44.425Z</updated>
    
    <content type="html"><![CDATA[<p> 通过更改部署中的 replicas（副本数）来完成伸缩</p> <a id="more"></a>  <h2 id="Scaling（伸缩）应用程序"><a href="#Scaling（伸缩）应用程序" class="headerlink" title="Scaling（伸缩）应用程序"></a>Scaling（伸缩）应用程序</h2><p> <strong>伸缩</strong> 的实现可以通过更改 nginx-deployment.yaml 文件中部署的 replicas（副本数）来完成 </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">4</span>    <span class="comment">#使用该Deployment创建两个应用程序实例</span></span><br></pre></td></tr></table></figure><p>修改了 Deployment 的 replicas 为 4 后，Kubernetes 又为该 Deployment 创建了 3 新的 Pod，这 4 个 Pod 有相同的标签。因此Service A通过标签选择器与新的 Pod建立了对应关系，将访问流量通过负载均衡在 4 个 Pod 之间进行转发。 </p><p> <img src="https://kuboard.cn/assets/img/module_05_scaling2.3f74dfba.svg" alt="Kubernetes教程：伸缩"> </p><h2 id="将-nginx-Deployment-扩容到-4-个副本"><a href="#将-nginx-Deployment-扩容到-4-个副本" class="headerlink" title="将 nginx Deployment 扩容到 4 个副本"></a>将 nginx Deployment 扩容到 4 个副本</h2><p>修改 nginx-deployment.yaml 文件，将 replicas 修改为 4</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">4</span>     <span class="comment">#通过更改部署中的 replicas（副本数）来完成扩展</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看结果</span></span><br><span class="line">watch kubectl get pods -o wide</span><br></pre></td></tr></table></figure><h1 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h1><p>用户期望应用程序始终可用，为此开发者/运维者在更新应用程序时要分多次完成。在 Kubernetes 中，这是通过 Rolling Update 滚动更新完成的。<strong>Rolling Update滚动更新</strong> 通过使用新版本的 Pod 逐步替代旧版本的 Pod 来实现 Deployment 的更新，从而实现零停机。新的 Pod 将在具有可用资源的 Node（节点）上进行调度。</p><blockquote><p>Kubernetes 更新多副本的 Deployment 的版本时，会逐步的创建新版本的 Pod，逐步的停止旧版本的 Pod，以便使应用一直处于可用状态。这个过程中，Service 能够监视 Pod 的状态，将流量始终转发到可用的 Pod 上。</p></blockquote><h2 id="滚动更新步骤"><a href="#滚动更新步骤" class="headerlink" title="滚动更新步骤"></a>滚动更新步骤</h2><p>1.原本 Service A 将流量负载均衡到 4 个旧版本的 Pod （当中的容器为 绿色）上 </p><p> 1.原本 Service A 将流量负载均衡到 4 个旧版本的 Pod （当中的容器为 绿色）上 </p><p> <img src="https://kuboard.cn/assets/img/module_06_rollingupdates1.3f74dfba.svg" alt="Kubernetes教程：滚动更新1"> </p><p>2.更新完 Deployment 部署文件中的镜像版本后，master 节点选择了一个 worker 节点，并根据新的镜像版本创建 Pod（紫色容器）。新 Pod 拥有唯一的新的 IP。同时，master 节点选择一个旧版本的 Pod 将其移除。</p><p>此时，Service A 将新 Pod 纳入到负载均衡中，将旧Pod移除</p><p> <img src="https://kuboard.cn/assets/img/module_06_rollingupdates2.62afd5b1.svg" alt="Kubernetes教程：滚动更新2"> </p><ol start="3"><li><p>同步骤2，再创建一个新的 Pod 替换一个原有的 Pod  <img src="https://kuboard.cn/assets/img/module_06_rollingupdates3.dc3754d9.svg" alt="Kubernetes教程：滚动更新3"> </p></li><li><p>如此 Rolling Update 滚动更新，直到所有旧版本 Pod 均移除，新版本 Pod 也达到 Deployment 部署文件中定义的副本数，则滚动更新完成 </p><h2 id="更新-nginx-Deployment"><a href="#更新-nginx-Deployment" class="headerlink" title="更新 nginx Deployment"></a>更新 nginx Deployment</h2></li></ol><h6 id="修改-nginx-deployment-yaml-文件"><a href="#修改-nginx-deployment-yaml-文件" class="headerlink" title="修改 nginx-deployment.yaml 文件"></a><strong>修改 nginx-deployment.yaml 文件</strong></h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.8</span>   <span class="comment">#使用镜像nginx:1.8替换原来的nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看过程及结果，可观察到 pod 逐个被替换的过程。</span></span><br><span class="line">watch kubectl get pods -l app=nginx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 通过更改部署中的 replicas（副本数）来完成伸缩&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>Service服务</title>
    <link href="http://yoursite.com/2020/03/25/Service%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/03/25/Service%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-03-25T07:09:33.000Z</published>
    <updated>2020-03-25T08:29:26.546Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes Service（服务）概述</p> <a id="more"></a> <h2 id="Service（服务）概述"><a href="#Service（服务）概述" class="headerlink" title="Service（服务）概述"></a>Service（服务）概述</h2><p>Pod 有自己的生命周期。当 worker node（节点）故障时，节点上运行的 Pod（容器组）也会消失。然后，Deployment 可以通过创建新的 Pod（容器组）来动态地将群集调整回原来的状态，以使应用程序保持运行。 </p><h3 id="Service的作用："><a href="#Service的作用：" class="headerlink" title="Service的作用："></a>Service的作用：</h3><p>由于 Kubernetes 集群中每个 Pod（容器组）都有一个唯一的 IP 地址（即使是同一个 Node 上的不同 Pod），service 可以解决为前端系统屏蔽后端系统的 Pod（容器组）在销毁、创建过程中所带来的 IP 地址的变化。</p><p>Kubernetes 中的 <strong>Service（服务）</strong> 提供了这样的一个抽象层，它选择具备某些特征的 Pod（容器组）并为它们定义一个访问方式。Service（服务）使 Pod（容器组）之间的相互依赖解耦（原本从一个 Pod 中访问另外一个 Pod，需要知道对方的 IP 地址）。一个 Service（服务）选定哪些 <strong>Pod（容器组）</strong> 通常由 <strong>LabelSelector(标签选择器)</strong> 来决定。  </p><p>在创建Service的时候，通过设置配置文件中的 spec.type 字段的值，可以以不同方式向外部暴露应用程序： </p><ul><li><p><strong>ClusterIP</strong>（默认）</p><p>在群集中的内部IP上公布服务，这种方式的 Service（服务）只在集群内部可以访问到</p></li><li><p><strong>NodePort</strong></p><p>使用 NAT 在集群中每个的同一端口上公布服务。这种方式下，可以通过访问集群中任意节点+端口号的方式访问服务 <code>:</code>。此时 ClusterIP 的访问方式仍然可用。</p></li><li><p><strong>LoadBalancer</strong></p><p>在云环境中（需要云供应商可以支持）创建一个集群外部的负载均衡器，并为使用该负载均衡器的 IP 地址作为服务的访问地址。此时 ClusterIP 和 NodePort 的访问方式仍然可用。</p></li></ul><p>Service是一个抽象层，它通过 LabelSelector 选择了一组 Pod（容器组），把这些 Pod 的指定端口公布到到集群外部，并支持负载均衡和服务发现。</p><ul><li>公布 Pod 的端口以使其可访问</li><li>在多个 Pod 间实现负载均衡</li><li>使用 Label 和 LabelSelector</li></ul><h2 id="服务和标签"><a href="#服务和标签" class="headerlink" title="服务和标签"></a>服务和标签</h2><p> 下图中有两个服务Service A(黄色虚线)和Service B(蓝色虚线) Service A 将请求转发到 IP 为 10.10.10.1 的Pod上， Service B 将请求转发到 IP 为 10.10.10.2、10.10.10.3、10.10.10.4 的Pod上。 </p><p> <img src="https://kuboard.cn/assets/img/module_04_services.11cdc7bc.svg" alt="Kubernetes教程：服务和标签"> </p><p> Service 将外部请求路由到一组 Pod 中，它提供了一个抽象层，使得 Kubernetes 可以在不影响服务调用者的情况下，动态调度容器组 </p><p>Service使用 Labels、LabelSelector (标签和选择器 匹配一组 Pod。Labels（标签）是附加到 Kubernetes 对象的键/值对，其用途有多种：</p><ul><li>将 Kubernetes 对象（Node、Deployment、Pod、Service等）指派用于开发环境、测试环境或生产环境</li><li>嵌入版本标签，使用标签区别不同应用软件版本</li><li>使用标签对 Kubernetes 对象进行分类</li></ul><h3 id="Labels（标签）和-LabelSelector（标签选择器）之间的关联关系"><a href="#Labels（标签）和-LabelSelector（标签选择器）之间的关联关系" class="headerlink" title="Labels（标签）和 LabelSelector（标签选择器）之间的关联关系"></a>Labels（标签）和 LabelSelector（标签选择器）之间的关联关系</h3><ul><li><p>Deployment B 含有 LabelSelector 为 app=B 通过此方式声明含有 app=B 标签的 Pod 与之关联</p></li><li><p>通过 Deployment B 创建的 Pod 包含标签为 app=B</p></li><li><p>Service B 通过标签选择器 app=B 选择可以路由的 Pod</p><p><img src="https://kuboard.cn/assets/img/module_04_labels.3255e3d0.svg" alt="Kubernetes教程：服务和标签"> </p><p>Labels（标签）可以在创建 Kubernetes 对象时附加上去，也可以在创建之后再附加上去。任何时候都可以修改一个 Kubernetes 对象的 Labels（标签） </p></li></ul><h2 id="nginx-Deployment-创建一个-Service"><a href="#nginx-Deployment-创建一个-Service" class="headerlink" title="nginx Deployment 创建一个 Service"></a>nginx Deployment 创建一个 Service</h2><h6 id="创建nginx的Deployment中定义了Labels，如下："><a href="#创建nginx的Deployment中定义了Labels，如下：" class="headerlink" title="创建nginx的Deployment中定义了Labels，如下："></a>创建nginx的Deployment中定义了Labels，如下：</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span><span class="comment">#译名为元数据，即Deployment的一些基本属性和信息</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span><span class="comment">#Deployment的名称</span></span><br><span class="line">  <span class="attr">labels:</span><span class="comment">#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span><span class="comment">#为该Deployment设置key为app，value为nginx的标签</span></span><br></pre></td></tr></table></figure><h6 id="创建文件-nginx-service-yaml"><a href="#创建文件-nginx-service-yaml" class="headerlink" title="创建文件 nginx-service.yaml"></a><strong>创建文件 nginx-service.yaml</strong></h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span><span class="comment">#Service 的名称</span></span><br><span class="line">  <span class="attr">labels:</span>     <span class="comment">#Service 自己的标签</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span><span class="comment">#为该 Service 设置 key 为 app，value 为 nginx 的标签</span></span><br><span class="line"><span class="attr">spec:</span>    <span class="comment">#这是关于该 Service 的定义，描述了 Service 如何选择 Pod，如何被访问</span></span><br><span class="line">  <span class="attr">selector:</span>    <span class="comment">#标签选择器</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span><span class="comment">#选择包含标签 app:nginx 的 Pod</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span><span class="comment">#端口的名字</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span>    <span class="comment">#协议类型 TCP/UDP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span>        <span class="comment">#集群内的其他容器组可通过 80 端口访问 Service</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">32600</span>   <span class="comment">#通过任意节点的 32600 端口访问 Service</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span><span class="comment">#将请求转发到匹配 Pod 的 80 端口</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span><span class="comment">#Serive的类型，ClusterIP/NodePort/LoaderBalancer</span></span><br></pre></td></tr></table></figure><p><strong>执行命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-service.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查执行结果</span></span><br><span class="line">kubectl get services -o wide   <span class="comment">#可查看到名称为 nginx-service 的服务。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#访问服务</span></span><br><span class="line">curl &lt;任意节点的 IP&gt;:32600</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes Service（服务）概述&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>查看Pods/Nodes</title>
    <link href="http://yoursite.com/2020/03/25/%E6%9F%A5%E7%9C%8BPods-Nodes/"/>
    <id>http://yoursite.com/2020/03/25/%E6%9F%A5%E7%9C%8BPods-Nodes/</id>
    <published>2020-03-25T06:05:21.000Z</published>
    <updated>2020-03-25T06:21:04.946Z</updated>
    
    <content type="html"><![CDATA[<p>了解 Pod 和 Node</p> <a id="more"></a> <h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>​    Pod中的容器共享 IP 地址和端口空间（同一 Pod 中的不同 container 端口不能相互冲突），始终位于同一位置并共同调度，并在同一节点上的共享上下文中运行。（同一个Pod内的容器可以localhost + 端口互相访问）。 </p><p>​    当在 k8s 上创建 Deployment 时，会在集群上创建包含容器的 Pod (而不是直接创建容器)。每个Pod都与运行它的 worker 节点（Node）绑定，并保持在那里直到终止或被删除。如果节点（Node）发生故障，则会在群集中的其他可用节点（Node）上运行相同的 Pod（从同样的镜像创建 Container，使用同样的配置，IP 地址不同，Pod 名字不同）。 </p><ul><li>Pod（容器组）是 k8s 集群上的最基本的单元。</li><li>Pod 是一组容器（可包含一个或多个应用程序容器），以及共享存储（卷 Volumes）、IP 地址和有关如何运行容器的信息。 </li><li>如果多个容器紧密耦合并且需要共享磁盘等资源，则应该被部署在同一个Pod（容器组）中 </li></ul><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p> <img src="https://kuboard.cn/assets/img/module_03_nodes.38f0ef71.svg" alt="Kubernetes教程：Node概念"> </p><ol><li>Pod（容器组）总是在 <strong>Node（节点）</strong> 上运行。</li><li>Node（节点）是 kubernetes 集群中的计算机，可以是虚拟机或物理机。</li><li>每个 Node（节点）都由 master 管理。</li><li>一个 Node（节点）可以有多个Pod（容器组），kubernetes master 会根据每个 Node（节点）上可用资源的情况，自动调度 Pod（容器组）到最佳的 Node（节点）上。</li></ol><h6 id="每个Node（节点）至少运行："><a href="#每个Node（节点）至少运行：" class="headerlink" title="每个Node（节点）至少运行："></a>每个Node（节点）至少运行：</h6><ul><li>Kubelet，负责 master 节点和 worker 节点之间通信的进程；管理 Pod（容器组）和 Pod（容器组）内运行的 Container（容器）。</li><li>容器运行环境（如Docker）负责下载镜像、创建和运行容器等。</li></ul><h2 id="相关命令操作"><a href="#相关命令操作" class="headerlink" title="相关命令操作"></a>相关命令操作</h2><h6 id="kubectl-get-显示资源列表"><a href="#kubectl-get-显示资源列表" class="headerlink" title="kubectl get - 显示资源列表"></a><strong>kubectl get</strong> - 显示资源列表</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get 资源类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取类型为Deployment的资源列表</span></span><br><span class="line">kubectl get deployments</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取类型为Pod的资源列表</span></span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取类型为Node的资源列表</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有名称空间的 Deployment</span></span><br><span class="line">kubectl get deployments -A</span><br><span class="line">kubectl get deployments --all-namespaces</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 kube-system 名称空间的 Deployment</span></span><br><span class="line">kubectl get deployments -n kube-system</span><br></pre></td></tr></table></figure><h6 id="kubectl-describe-显示有关资源的详细信息"><a href="#kubectl-describe-显示有关资源的详细信息" class="headerlink" title="kubectl describe - 显示有关资源的详细信息"></a><strong>kubectl describe</strong> - 显示有关资源的详细信息</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl describe 资源类型 资源名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看名称为nginx-XXXXXX的Pod的信息</span></span><br><span class="line">kubectl describe pod nginx-XXXXXX</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看名称为nginx的Deployment的信息</span></span><br><span class="line">kubectl describe deployment nginx</span><br></pre></td></tr></table></figure><h6 id="kubectl-logs-查看pod中的容器的打印日志（和命令docker-logs-类似）"><a href="#kubectl-logs-查看pod中的容器的打印日志（和命令docker-logs-类似）" class="headerlink" title="kubectl logs - 查看pod中的容器的打印日志（和命令docker logs 类似）"></a><strong>kubectl logs</strong> - 查看pod中的容器的打印日志（和命令docker logs 类似）</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl logs Pod名称</span></span><br><span class="line">kubectl logs -f nginx-pod-XXXXXXX</span><br></pre></td></tr></table></figure><h6 id="kubectl-exec-在pod中的容器环境内执行命令-和命令docker-exec-类似"><a href="#kubectl-exec-在pod中的容器环境内执行命令-和命令docker-exec-类似" class="headerlink" title="kubectl exec - 在pod中的容器环境内执行命令(和命令docker exec 类似)"></a><strong>kubectl exec</strong> - 在pod中的容器环境内执行命令(和命令docker exec 类似)</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl exec Pod名称 操作命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在名称为nginx-pod-xxxxxx的Pod中运行bash</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx-pod-xxxxxx /bin/bash</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 Pod 和 Node&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>k8s部署一个应用程序</title>
    <link href="http://yoursite.com/2020/03/25/k8s%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/03/25/k8s%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-03-25T05:49:00.000Z</published>
    <updated>2020-03-25T05:59:21.447Z</updated>
    
    <content type="html"><![CDATA[<p> 使用 kubectl 在 k8s 上部署第一个应用程序。 </p> <a id="more"></a> <h2 id="Deployment概念"><a href="#Deployment概念" class="headerlink" title="Deployment概念"></a>Deployment概念</h2><p>​    通过发布 Deployment，可以创建应用程序 (docker image) 的实例 (docker container)，这个实例会被包含在称为 <strong>Pod</strong> 的概念中，<strong>Pod</strong> 是 k8s 中最小可管理单元。</p><p>​    在 k8s 集群中发布 Deployment 后，Deployment 将指示 k8s 如何创建和更新应用程序的实例，master 节点将应用程序实例调度到集群中的具体的节点上。</p><p>​    创建应用程序实例后，Kubernetes Deployment Controller 会持续监控这些实例。如果运行实例的 worker 节点关机或被删除，则 Kubernetes Deployment Controller 将在群集中资源最优的另一个 worker 节点上重新创建一个新的实例。<strong>这提供了一种自我修复机制来解决机器故障或维护问题。</strong></p><p>​    通过创建应用程序实例并确保它们在集群节点中的运行实例个数，Kubernetes Deployment 提供了一种完全不同的方式来管理应用程序。</p><p> <img src="https://kuboard.cn/assets/img/module_02_first_app.25e902c4.svg" alt="Kubernetes教程：部署第一个应用程序"> </p><p> Deployment 处于 master 节点上，通过发布 Deployment，master 节点会选择合适的 worker 节点创建 Container（即图中的正方体），Container 会被包含在 Pod （即蓝色圆圈）里。 </p><h2 id="部署-nginx-Deployment"><a href="#部署-nginx-Deployment" class="headerlink" title="部署 nginx Deployment"></a>部署 nginx Deployment</h2><h6 id="创建文件-nginx-deployment-yaml"><a href="#创建文件-nginx-deployment-yaml" class="headerlink" title="创建文件 nginx-deployment.yaml"></a>创建文件 nginx-deployment.yaml</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span><span class="comment">#与k8s集群版本有关，使用 kubectl api-versions 即可查看当前集群支持的版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span><span class="comment">#该配置的类型，我们使用的是 Deployment</span></span><br><span class="line"><span class="attr">metadata:</span>        <span class="comment">#译名为元数据，即 Deployment 的一些基本属性和信息</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span><span class="comment">#Deployment 的名称</span></span><br><span class="line">  <span class="attr">labels:</span>    <span class="comment">#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组，目前不需要理解</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span><span class="comment">#为该Deployment设置key为app，value为nginx的标签</span></span><br><span class="line"><span class="attr">spec:</span>        <span class="comment">#这是关于该Deployment的描述，可以理解为你期待该Deployment在k8s中如何使用</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span><span class="comment">#使用该Deployment创建一个应用程序实例</span></span><br><span class="line">  <span class="attr">selector:</span>    <span class="comment">#标签选择器，与上面的标签共同作用，目前不需要理解</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment">#选择包含标签app:nginx的资源</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span>    <span class="comment">#这是选择或创建的Pod的模板</span></span><br><span class="line">    <span class="attr">metadata:</span><span class="comment">#Pod的元数据</span></span><br><span class="line">      <span class="attr">labels:</span><span class="comment">#Pod的标签，上面的selector即选择包含标签app:nginx的Pod</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span>    <span class="comment">#期望Pod实现的功能（即在pod中部署）</span></span><br><span class="line">      <span class="attr">containers:</span><span class="comment">#生成container，与docker中的container是同一种</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span><span class="comment">#container的名称</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span><span class="comment">#使用镜像nginx:1.7.9创建container，该container默认80端口可访问</span></span><br></pre></td></tr></table></figure><h6 id="应用-YAML-文件"><a href="#应用-YAML-文件" class="headerlink" title="应用 YAML 文件"></a><strong>应用 YAML 文件</strong></h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure><h6 id="查看部署结果"><a href="#查看部署结果" class="headerlink" title="查看部署结果"></a><strong>查看部署结果</strong></h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Deployment</span></span><br><span class="line">kubectl get deployments</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod</span></span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 使用 kubectl 在 k8s 上部署第一个应用程序。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>kubectl 命令技巧大全</title>
    <link href="http://yoursite.com/2020/03/20/kubectl%20%E5%91%BD%E4%BB%A4%E6%8A%80%E5%B7%A7%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2020/03/20/kubectl%20%E5%91%BD%E4%BB%A4%E6%8A%80%E5%B7%A7%E5%A4%A7%E5%85%A8/</id>
    <published>2020-03-20T03:13:20.000Z</published>
    <updated>2020-03-20T07:20:09.424Z</updated>
    
    <content type="html"><![CDATA[<p>一些基本的kubernets操作命令</p> <a id="more"></a> <h1 id="kubectl-命令技巧大全"><a href="#kubectl-命令技巧大全" class="headerlink" title="kubectl 命令技巧大全"></a><strong>kubectl 命令技巧大全</strong></h1><h2 id="Kubectl-自动补全"><a href="#Kubectl-自动补全" class="headerlink" title="Kubectl 自动补全"></a><strong>Kubectl 自动补全</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install -y bash-completion</span><br><span class="line"></span><br><span class="line">source &#x2F;usr&#x2F;share&#x2F;bash-completion&#x2F;bash_completion</span><br><span class="line"></span><br><span class="line">source &lt;(kubectl completion bash)</span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a><strong>创建对象</strong></h2><p>Kubernetes 的清单文件可以使用 json 或 yaml 格式定义。可以以 .yaml、.yml、或者 .json 为扩展名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f .&#x2F;my-manifest.yaml           # 创建资源</span><br><span class="line"></span><br><span class="line">$ kubectl create -f .&#x2F;my1.yaml -f .&#x2F;my2.yaml     # 使用多个文件创建资源</span><br><span class="line"></span><br><span class="line">$ kubectl create -f .&#x2F;dir                        # 使用目录下的所有清单文件来创建资源</span><br><span class="line"></span><br><span class="line">$ kubectl create -f https:&#x2F;&#x2F;git.io&#x2F;vPieo         # 使用 url 来创建资源</span><br><span class="line"></span><br><span class="line">$ kubectl run nginx --image&#x3D;nginx                # 启动一个 nginx 实例</span><br><span class="line"></span><br><span class="line">$ kubectl explain pods,svc                       # 获取 pod 和 svc 的文档</span><br></pre></td></tr></table></figure><h2 id="显示和查找资源"><a href="#显示和查找资源" class="headerlink" title="显示和查找资源"></a><strong>显示和查找资源</strong></h2><p> 列出所有 namespace 中的所有service </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get services</span><br></pre></td></tr></table></figure><p>列出所有 namespace 中的所有 pod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --all-namespaces</span><br></pre></td></tr></table></figure><p> 列出所有 pod 并显示详细信息 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -o wide</span><br></pre></td></tr></table></figure><p> 列出指定 deployment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deployment my-dep</span><br></pre></td></tr></table></figure><p> 列出该 namespace 中的所有 pod 包括未初始化的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --include-uninitialized</span><br></pre></td></tr></table></figure><p>使用详细输出来描述命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> $ kubectl describe nodes my-node </span><br><span class="line"></span><br><span class="line">$ kubectl describe pods my-pod </span><br><span class="line"></span><br><span class="line">$ kubectl get services --sort-by&#x3D;.metadata.name</span><br></pre></td></tr></table></figure><p> 根据重启次数排序列出 pod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --sort-by&#x3D;&#39;.status.containerStatuses[0].restartCount&#39;</span><br></pre></td></tr></table></figure><p>获取所有具有 app=cassandra 的 pod 中的 version 标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --selector&#x3D;app&#x3D;cassandra rc -o \  jsonpath&#x3D;&#39;&#123;.items[*].metadata.labels.version&#125;&#39;</span><br></pre></td></tr></table></figure><p> 获取所有节点的 ExternalIP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes -o jsonpath&#x3D;&#39;&#123;.items[*].status.addresses[?(@.type&#x3D;&#x3D;&quot;ExternalIP&quot;)].address&#125;&#39;</span><br></pre></td></tr></table></figure><p>列出属于某个 PC 的 Pod 的名字，“jq”命令用于转换复杂的 jsonpath，参考 <a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">https://stedolan.github.io/jq/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> $ sel&#x3D;$&#123;$(kubectl get rc my-rc --output&#x3D;json | jq -j &#39;.spec.selector | to_entries | .[] | &quot;\(.key)&#x3D;\(.value),&quot;&#39;)%?&#125; </span><br><span class="line"></span><br><span class="line">$ echo $(kubectl get pods --selector&#x3D;$sel --output&#x3D;jsonpath&#x3D;&#123;.items..metadata.name&#125;)</span><br></pre></td></tr></table></figure><p>查看哪些节点已就绪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ JSONPATH&#x3D;&#39;&#123;range .items[*]&#125;&#123;@.metadata.name&#125;:&#123;range @.status.conditions[*]&#125;&#123;@.type&#125;&#x3D;&#123;@.status&#125;;&#123;end&#125;&#123;end&#125;&#39; \ &amp;&amp; kubectl get nodes -o jsonpath&#x3D;&quot;$JSONPATH&quot; | grep &quot;Ready&#x3D;True&quot;</span><br></pre></td></tr></table></figure><p> 列出当前 Pod 中使用的 Secret</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -o json | jq &#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39; | grep -v null | sort | uniq</span><br></pre></td></tr></table></figure><h2 id="更新资源"><a href="#更新资源" class="headerlink" title="更新资源"></a><strong>更新资源</strong></h2><p>滚动更新 pod frontend-v1 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rolling-update frontend-v1 -f frontend-v2.json</span><br></pre></td></tr></table></figure><p>更新资源名称并更新镜像            </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rolling-update frontend-v1 frontend-v2 --image&#x3D;image:v2</span><br></pre></td></tr></table></figure><p>更新 frontend pod 中的镜像 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rolling-update frontend --image&#x3D;image:v2</span><br></pre></td></tr></table></figure><p>退出已存在的进行中的滚动更新                  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rolling-update frontend-v1 frontend-v2 --rollback</span><br></pre></td></tr></table></figure><p>基于 stdin 输入的 JSON 替换 pod </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat pod.json | kubectl replace -f -</span><br></pre></td></tr></table></figure><p>强制替换，删除后重新创建资源。会导致服务中断。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl replace --force -f .&#x2F;pod.json</span><br></pre></td></tr></table></figure><p>为 nginx RC 创建服务，启用本地 80 端口连接到容器上的 8000 端口 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl expose rc nginx --port&#x3D;80 --target-port&#x3D;8000</span><br></pre></td></tr></table></figure><p>更新单容器 pod 的镜像版本（tag）到 v4 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod mypod -o yaml | sed &#39;s&#x2F;\(image: myimage\):.*$&#x2F;\1:v4&#x2F;&#39; | kubectl replace -f -</span><br></pre></td></tr></table></figure><p>添加标签 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl label pods my-pod new-label&#x3D;awesome</span><br></pre></td></tr></table></figure><p>添加注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl annotate pods my-pod icon-url&#x3D;http:&#x2F;&#x2F;goo.gl&#x2F;XXBTWq</span><br></pre></td></tr></table></figure><p>自动扩展 deployment “foo”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl autoscale deployment foo --min&#x3D;2 --max&#x3D;10</span><br></pre></td></tr></table></figure><h2 id="删除资源"><a href="#删除资源" class="headerlink" title="删除资源"></a><strong>删除资源</strong></h2><p># 删除 pod.json 文件中定义的类型和名称的 pod </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f .&#x2F;pod.json</span><br></pre></td></tr></table></figure><p>删除名为“baz”的 pod 和名为“foo”的 service </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pod,service baz foo</span><br></pre></td></tr></table></figure><p>删除具有 name=myLabel 标签的 pod 和 serivce </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pods,services -l name&#x3D;myLabel</span><br></pre></td></tr></table></figure><p>删除具有 name=myLabel 标签的 pod 和 service，包括尚未初始化的 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pods,services -l name&#x3D;myLabel --include-uninitialized</span><br></pre></td></tr></table></figure><p>删除 my-ns namespace 下的所有 pod 和 serivce，包括尚未初始化的  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n my-ns delete po,svc --all</span><br></pre></td></tr></table></figure><h2 id="与运行中的Pod交互"><a href="#与运行中的Pod交互" class="headerlink" title="与运行中的Pod交互"></a><strong>与运行中的Pod交互</strong></h2><p># dump 输出 pod 的日志（stdout） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs my-pod</span><br></pre></td></tr></table></figure><p>dump 输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs my-pod -c my-container</span><br></pre></td></tr></table></figure><p>流式输出 pod 的日志（stdout） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs -f my-pod</span><br></pre></td></tr></table></figure><p>流式输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs -f my-pod -c my-container</span><br></pre></td></tr></table></figure><p>交互式 shell 的方式运行 pod </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run -i --tty busybox --image&#x3D;busybox -- sh</span><br></pre></td></tr></table></figure><p>连接到运行中的容器   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl attach my-pod -i</span><br></pre></td></tr></table></figure><p>转发 pod 中的 6000 端口到本地的 5000 端口 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl port-forward my-pod 5000:6000</span><br></pre></td></tr></table></figure><p>在已存在的容器中执行命令（只有一个容器的情况下） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl exec my-pod -- ls &#x2F;</span><br></pre></td></tr></table></figure><p>在已存在的容器中执行命令（pod 中有多个容器的情况下） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl exec my-pod -c my-container -- ls &#x2F;</span><br></pre></td></tr></table></figure><p>显示指定 pod 和容器的指标度量    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl top pod POD_NAME --containers</span><br></pre></td></tr></table></figure><h2 id="与节点和集群交互"><a href="#与节点和集群交互" class="headerlink" title="与节点和集群交互"></a><strong>与节点和集群交互</strong></h2><p># 标记 my-node 不可调度 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cordon my-node</span><br></pre></td></tr></table></figure><p>清空 my-node 以待维护 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl drain my-node</span><br></pre></td></tr></table></figure><p>标记 my-node 可调度 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl uncordon my-node</span><br></pre></td></tr></table></figure><p>显示 my-node 的指标度量 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl top node my-node</span><br></pre></td></tr></table></figure><p>显示 master 和服务的地址 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cluster-info</span><br></pre></td></tr></table></figure><p>将当前集群状态输出到 stdout </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cluster-info dump</span><br></pre></td></tr></table></figure><p>将当前集群状态输出到 /path/to/cluster-state </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cluster-info dump --output-directory&#x3D;&#x2F;path&#x2F;to&#x2F;cluster-state</span><br></pre></td></tr></table></figure><p>如果该键和影响的污点（taint）已存在，则使用指定的值替换 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl taint nodes foo dedicated&#x3D;special-user:NoSchedule</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>资源类型</strong></th><th><strong>缩写别名</strong></th></tr></thead><tbody><tr><td>clusters</td><td></td></tr><tr><td>componentstatuses</td><td>cs</td></tr><tr><td>configmaps</td><td>cm</td></tr><tr><td>daemonsets</td><td>ds</td></tr><tr><td>deployments</td><td>deploy</td></tr><tr><td>endpoints</td><td>ep</td></tr><tr><td>event</td><td>ev</td></tr><tr><td>horizontalpodautoscalers</td><td>hpa</td></tr><tr><td>ingresses</td><td>ing</td></tr><tr><td>jobs</td><td></td></tr><tr><td>limitranges</td><td>limits</td></tr><tr><td>namespaces</td><td>ns</td></tr><tr><td>networkpolicies</td><td></td></tr><tr><td>nodes</td><td>no</td></tr><tr><td>statefulsets</td><td></td></tr><tr><td>persistentvolumeclaims</td><td>pvc</td></tr><tr><td>persistentvolumes</td><td>pv</td></tr><tr><td>pods</td><td>po</td></tr><tr><td>podsecuritypolicies</td><td>psp</td></tr><tr><td>podtemplates</td><td></td></tr><tr><td>replicasets</td><td>rs</td></tr><tr><td>replicationcontrollers</td><td>rc</td></tr><tr><td>resourcequotas</td><td>quota</td></tr><tr><td>cronjob</td><td></td></tr><tr><td>secrets</td><td></td></tr><tr><td>serviceaccount</td><td>sa</td></tr><tr><td>services</td><td>svc</td></tr><tr><td>storageclasses</td><td></td></tr></tbody></table><h2 id="kubectl-get-显示资源列表"><a href="#kubectl-get-显示资源列表" class="headerlink" title="kubectl get - 显示资源列表"></a>kubectl get - 显示资源列表</h2><p>#获取类型为Deployment的资源列表 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments</span><br></pre></td></tr></table></figure><p>#获取类型为Pod的资源列表 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>#获取类型为Node的资源列表 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><p>在命令后增加 -A 或 –all-namespaces 可查看所有名称空间中的对象，使用参数 -n 可查看指定名称空间的对象，例如</p><p># 查看所有名称空间的 Deployment </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments -A </span><br><span class="line">kubectl get deployments --all-namespaces</span><br></pre></td></tr></table></figure><p>查看 kube-system 名称空间的 Deployment </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments -n kube-system</span><br></pre></td></tr></table></figure><p>检查 kubectl 是否知道集群地址及凭证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl config view</span><br></pre></td></tr></table></figure><p>通过 kubectl cluster-info 命令获得这些服务列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ebs ~]# kubectl cluster-info </span><br><span class="line"></span><br><span class="line">Kubernetes master is running at https:&#x2F;&#x2F;172.16.121.88:6443 KubeDNS is running at https:&#x2F;&#x2F;172.16.121.88:6443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;kube-system&#x2F;services&#x2F;kube-dns:dns&#x2F;proxy </span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use &#39;kubectl cluster-info dump&#39;.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些基本的kubernets操作命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>Kubernetes核心概念</title>
    <link href="http://yoursite.com/2020/03/20/Kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2020/03/20/Kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</id>
    <published>2020-03-20T03:10:20.000Z</published>
    <updated>2020-03-25T09:16:34.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Kubernetes？"><a href="#什么是Kubernetes？" class="headerlink" title="什么是Kubernetes？"></a>什么是Kubernetes？</h2><p>Kubernetes（k8s）是自动化容器操作的开源平台，这些操作包括部署，调度和节点集群间扩展。如果你曾经用过Docker容器技术部署容器，那么可以将Docker看成Kubernetes内部使用的低级别组件。Kubernetes不仅仅支持Docker，还支持Rocket，这是另一种容器技术。 使用Kubernetes可以：</p><ul><li>自动化容器的部署和复制</li><li>随时扩展或收缩容器规模</li><li>将容器组织成组，并且提供容器间的负载均衡</li><li>很容易地升级应用程序容器的新版本</li><li>提供容器弹性，如果容器失效就替换它，等等…</li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>集群是一组节点，这些节点可以是物理服务器或者虚拟机，之上安装了Kubernetes平台。下图展示这样的集群。注意该图为了强调核心概念有所简化。这里可以看到一个典型的Kubernetes架构图。</p><p><img src="https://kuboard.cn/assets/img/d7ce07842371eab180725bab5164ec17.d58ea9cc.png" alt="Kubernetes教程：Kubernetes核心概念-集群"></p><p>上图可以看到如下组件，使用特别的图标表示Service和Label：</p><ul><li>PodContainer（容器）</li><li>Label(<img src="data:image/png;base64,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" alt="label">))（标签）</li><li>Replication Controller（复制控制器）</li><li>Service（<img src="data:image/png;base64,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" alt="enter image description here">）（服务）</li><li>Node（节点）</li><li>Kubernetes Master（Kubernetes主节点）</li></ul><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Pod（上图绿色方框）安排在节点上，包含一组容器和卷。同一个Pod里的容器共享同一个网络命名空间，可以使用localhost互相通信。Pod是短暂的，不是持续性实体。你可能会有这些问题：</p><ul><li>如果Pod是短暂的，那么我怎么才能持久化容器数据使其能够跨重启而存在呢？ 是的，Kubernetes支持 <strong><em>卷</em></strong> 的概念，因此可以使用持久化的卷类型。</li><li>是否手动创建Pod，如果想要创建同一个容器的多份拷贝，需要一个个分别创建出来么？可以手动创建单个Pod，但是也可以使用Replication Controller使用Pod模板创建出多份拷贝，下文会详细介绍。</li><li>如果Pod是短暂的，那么重启时IP地址可能会改变，那么怎么才能从前端容器正确可靠地指向后台容器呢？这时可以使用Service，下文会详细介绍。</li></ul><h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>正如图所示，一些Pod有Label（<img src="data:image/png;base64,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" alt="enter image description here">）。一个Label是attach到Pod的一对键/值对，用来传递用户定义的属性。比如，你可能创建了一个”tier”和“app”标签，通过Label（<strong>tier=frontend, app=myapp</strong>）来标记前端Pod容器，使用Label（<strong>tier=backend, app=myapp</strong>）标记后台Pod。然后可以使用 [Selectors] 选择带有特定Label的Pod，并且将Service或者Replication Controller应用到上面。</p><h2 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h2><p><em>是否手动创建Pod，如果想要创建同一个容器的多份拷贝，需要一个个分别创建出来么，能否将Pods划到逻辑组里？</em></p><p>Replication Controller确保任意时间都有指定数量的Pod“副本”在运行。如果为某个Pod创建了Replication Controller并且指定3个副本，它会创建3个Pod，并且持续监控它们。如果某个Pod不响应，那么Replication Controller会替换它，保持总数为3.如下面的动画所示：</p><p><img src="https://kuboard.cn/assets/img/03d07039d9fc80c0f692d6176f65936e.7af9fab5.gif" alt="Kubernetes教程：Kubernetes核心概念-Replication Controller"></p><p>如果之前不响应的Pod恢复了，现在就有4个Pod了，那么Replication Controller会将其中一个终止保持总数为3。如果在运行中将副本总数改为5，Replication Controller会立刻启动2个新Pod，保证总数为5。还可以按照这样的方式缩小Pod，这个特性在执行滚动 [升级] 时很有用。</p><p>当创建Replication Controller时，需要指定两个东西：</p><ol><li>Pod模板：用来创建Pod副本的模板</li><li>Label：Replication Controller需要监控的Pod的标签。现在已经创建了Pod的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是Service。</li></ol><p>TIP</p><p>最新 Kubernetes 版本里，推荐使用 Deployment</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p><em>如果Pods是短暂的，那么重启时IP地址可能会改变，怎么才能从前端容器正确可靠地指向后台容器呢？</em> [Service] <strong>抽象</strong> 现在，假定有2个后台Pod，并且定义后台Service的名称为‘backend-service’，label选择器为(tier=backend, app=myapp) 的Service会完成如下两件重要的事情：</p><ul><li>会为Service创建一个本地集群的DNS入口，因此前端Pod只需要DNS查找主机名为 ‘backend-service’，就能够解析出前端应用程序可用的IP地址。</li><li>现在前端已经得到了后台服务的IP地址，但是它应该访问2个后台Pod的哪一个呢？Service在这2个后台Pod之间提供透明的负载均衡，会将请求分发给其中的任意一个（如下面的动画所示）。通过每个Node上运行的代理（kube-proxy）完成。</li></ul><p>下述动画展示了Service的功能。注意该图作了很多简化。如果不进入网络配置，那么达到透明的负载均衡目标所涉及的底层网络和路由相对先进。如果有兴趣，有更深入的介绍。</p><p><img src="https://kuboard.cn/assets/img/e7a273fcdc03d2417b354b60c253552f.19ae82d9.gif" alt="Kubernetes教程：Kubernetes核心概念-Service"></p><p>每个节点都运行如下Kubernetes关键组件：</p><ul><li>Kubelet：是主节点代理。</li><li>Kube-proxy：Service使用其将链接路由到Pod，如上文所述。</li><li>Docker或Rocket：Kubernetes使用的容器技术来创建容器。</li></ul><h3 id="Kubernetes-Master"><a href="#Kubernetes-Master" class="headerlink" title="Kubernetes Master"></a>Kubernetes Master</h3><p>集群拥有一个Kubernetes Master（紫色方框）。Kubernetes Master提供集群的独特视角，并且拥有一系列组件，比如Kubernetes API Server。API Server提供可以用来和集群交互的REST端点。master节点包括用来创建和复制Pod的Replication Controller。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Kubernetes？&quot;&gt;&lt;a href=&quot;#什么是Kubernetes？&quot; class=&quot;headerlink&quot; title=&quot;什么是Kubernetes？&quot;&gt;&lt;/a&gt;什么是Kubernetes？&lt;/h2&gt;&lt;p&gt;Kubernetes（k8s）是自动化容器操
      
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo 使用</title>
    <link href="http://yoursite.com/2020/03/19/hexo%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/03/19/hexo%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-19T09:18:36.000Z</published>
    <updated>2020-03-23T07:14:57.409Z</updated>
    
    <content type="html"><![CDATA[<p>hexo 搭建、部署、操作；</p> <a id="more"></a> <p>_config.yml配置git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:  </span><br><span class="line">  type: &#39;git&#39;  </span><br><span class="line">  repo: git@github.com:yourname&#x2F;yourname.github.io.git  </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h5 id="上传github，推送文件步骤："><a href="#上传github，推送文件步骤：" class="headerlink" title="上传github，推送文件步骤："></a>上传github，推送文件步骤：</h5><p>hexo clean      hexo c   清除缓存文件 (db.json) 和已生成的静态文件 (public) </p><p>hexo generate   hexo g   生成静态文件 </p><p>hexo deploy     hexo d   部署网站 </p><p>执行端口启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -i 0.0.0.0 -p 8080</span><br></pre></td></tr></table></figure><p>绑定个人域名：</p><p>解析域名注意，博客网址中必须使用你github的用户名.</p><p><strong>布局（Layout）</strong></p><p>Hexo 有三种默认布局：post、page 和 draft。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td>post</td><td>source/_posts</td></tr><tr><td>page</td><td>source</td></tr><tr><td>draft</td><td>source/_drafts</td></tr></tbody></table><p><strong>hexo init</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init [ folder]</span><br></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><p><strong>hexo new</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><p>hexo new “post title with whitespace” </p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p, –path</td><td>自定义新文章的路径</td></tr><tr><td>-r, –replace</td><td>如果存在同名文章，将其替换</td></tr><tr><td>-s, –slug</td><td>文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br></pre></td></tr></table></figure><p>以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 “About me”</p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me</span><br></pre></td></tr></table></figure><p>此时 Hexo 会创建 source/_posts/about/me.md，同时 me.md 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo 搭建、部署、操作；&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
</feed>
