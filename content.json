{"meta":{"title":"拒绝再玩","subtitle":"","description":"","author":"duoyu","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"k8s","slug":"kubernetes/kubectl 命令技巧大全/kubectl 命令技巧大全","date":"2020-03-20T03:13:20.000Z","updated":"2020-03-20T06:30:02.217Z","comments":true,"path":"2020/03/20/kubernetes/kubectl 命令技巧大全/kubectl 命令技巧大全/","link":"","permalink":"http://yoursite.com/2020/03/20/kubernetes/kubectl%20%E5%91%BD%E4%BB%A4%E6%8A%80%E5%B7%A7%E5%A4%A7%E5%85%A8/kubectl%20%E5%91%BD%E4%BB%A4%E6%8A%80%E5%B7%A7%E5%A4%A7%E5%85%A8/","excerpt":"","text":"kubectl 命令技巧大全Kubectl 自动补全12345yum install -y bash-completionsource &#x2F;usr&#x2F;share&#x2F;bash-completion&#x2F;bash_completionsource &lt;(kubectl completion bash) 创建对象Kubernetes 的清单文件可以使用 json 或 yaml 格式定义。可以以 .yaml、.yml、或者 .json 为扩展名。 1234567891011$ kubectl create -f .&#x2F;my-manifest.yaml # 创建资源$ kubectl create -f .&#x2F;my1.yaml -f .&#x2F;my2.yaml # 使用多个文件创建资源$ kubectl create -f .&#x2F;dir # 使用目录下的所有清单文件来创建资源$ kubectl create -f https:&#x2F;&#x2F;git.io&#x2F;vPieo # 使用 url 来创建资源$ kubectl run nginx --image&#x3D;nginx # 启动一个 nginx 实例$ kubectl explain pods,svc # 获取 pod 和 svc 的文档 显示和查找资源 列出所有 namespace 中的所有service 1$ kubectl get services 列出所有 namespace 中的所有 pod 1$ kubectl get pods --all-namespaces 列出所有 pod 并显示详细信息 1$ kubectl get pods -o wide 列出指定 deployment 1$ kubectl get deployment my-dep 列出该 namespace 中的所有 pod 包括未初始化的 1$ kubectl get pods --include-uninitialized 使用详细输出来描述命令 12345 $ kubectl describe nodes my-node $ kubectl describe pods my-pod $ kubectl get services --sort-by&#x3D;.metadata.name 根据重启次数排序列出 pod 1$ kubectl get pods --sort-by&#x3D;&#39;.status.containerStatuses[0].restartCount&#39; 获取所有具有 app=cassandra 的 pod 中的 version 标签 1$ kubectl get pods --selector&#x3D;app&#x3D;cassandra rc -o \\ jsonpath&#x3D;&#39;&#123;.items[*].metadata.labels.version&#125;&#39; 获取所有节点的 ExternalIP 1$ kubectl get nodes -o jsonpath&#x3D;&#39;&#123;.items[*].status.addresses[?(@.type&#x3D;&#x3D;&quot;ExternalIP&quot;)].address&#125;&#39; 列出属于某个 PC 的 Pod 的名字，“jq”命令用于转换复杂的 jsonpath，参考 https://stedolan.github.io/jq/ 123 $ sel&#x3D;$&#123;$(kubectl get rc my-rc --output&#x3D;json | jq -j &#39;.spec.selector | to_entries | .[] | &quot;\\(.key)&#x3D;\\(.value),&quot;&#39;)%?&#125; $ echo $(kubectl get pods --selector&#x3D;$sel --output&#x3D;jsonpath&#x3D;&#123;.items..metadata.name&#125;) 查看哪些节点已就绪 1$ JSONPATH&#x3D;&#39;&#123;range .items[*]&#125;&#123;@.metadata.name&#125;:&#123;range @.status.conditions[*]&#125;&#123;@.type&#125;&#x3D;&#123;@.status&#125;;&#123;end&#125;&#123;end&#125;&#39; \\ &amp;&amp; kubectl get nodes -o jsonpath&#x3D;&quot;$JSONPATH&quot; | grep &quot;Ready&#x3D;True&quot; 列出当前 Pod 中使用的 Secret 1$ kubectl get pods -o json | jq &#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39; | grep -v null | sort | uniq 更新资源滚动更新 pod frontend-v1 1$ kubectl rolling-update frontend-v1 -f frontend-v2.json 更新资源名称并更新镜像 1$ kubectl rolling-update frontend-v1 frontend-v2 --image&#x3D;image:v2 更新 frontend pod 中的镜像 1$ kubectl rolling-update frontend --image&#x3D;image:v2 退出已存在的进行中的滚动更新 1$ kubectl rolling-update frontend-v1 frontend-v2 --rollback 基于 stdin 输入的 JSON 替换 pod 1$ cat pod.json | kubectl replace -f - 强制替换，删除后重新创建资源。会导致服务中断。 1$ kubectl replace --force -f .&#x2F;pod.json 为 nginx RC 创建服务，启用本地 80 端口连接到容器上的 8000 端口 1$ kubectl expose rc nginx --port&#x3D;80 --target-port&#x3D;8000 更新单容器 pod 的镜像版本（tag）到 v4 1$ kubectl get pod mypod -o yaml | sed &#39;s&#x2F;\\(image: myimage\\):.*$&#x2F;\\1:v4&#x2F;&#39; | kubectl replace -f - 添加标签 1$ kubectl label pods my-pod new-label&#x3D;awesome 添加注解 1$ kubectl annotate pods my-pod icon-url&#x3D;http:&#x2F;&#x2F;goo.gl&#x2F;XXBTWq 自动扩展 deployment “foo” 1$ kubectl autoscale deployment foo --min&#x3D;2 --max&#x3D;10 删除资源# 删除 pod.json 文件中定义的类型和名称的 pod 1$ kubectl delete -f .&#x2F;pod.json 删除名为“baz”的 pod 和名为“foo”的 service 1$ kubectl delete pod,service baz foo 删除具有 name=myLabel 标签的 pod 和 serivce 1$ kubectl delete pods,services -l name&#x3D;myLabel 删除具有 name=myLabel 标签的 pod 和 service，包括尚未初始化的 1$ kubectl delete pods,services -l name&#x3D;myLabel --include-uninitialized 删除 my-ns namespace 下的所有 pod 和 serivce，包括尚未初始化的 1$ kubectl -n my-ns delete po,svc --all 与运行中的Pod交互# dump 输出 pod 的日志（stdout） 1$ kubectl logs my-pod dump 输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用） 1$ kubectl logs my-pod -c my-container 流式输出 pod 的日志（stdout） 1$ kubectl logs -f my-pod 流式输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用） 1$ kubectl logs -f my-pod -c my-container 交互式 shell 的方式运行 pod 1$ kubectl run -i --tty busybox --image&#x3D;busybox -- sh 连接到运行中的容器 1$ kubectl attach my-pod -i 转发 pod 中的 6000 端口到本地的 5000 端口 1$ kubectl port-forward my-pod 5000:6000 在已存在的容器中执行命令（只有一个容器的情况下） 1$ kubectl exec my-pod -- ls &#x2F; 在已存在的容器中执行命令（pod 中有多个容器的情况下） 1$ kubectl exec my-pod -c my-container -- ls &#x2F; 显示指定 pod 和容器的指标度量 1$ kubectl top pod POD_NAME --containers 与节点和集群交互# 标记 my-node 不可调度 1$ kubectl cordon my-node 清空 my-node 以待维护 1$ kubectl drain my-node 标记 my-node 可调度 1$ kubectl uncordon my-node 显示 my-node 的指标度量 1$ kubectl top node my-node 显示 master 和服务的地址 1$ kubectl cluster-info 将当前集群状态输出到 stdout 1$ kubectl cluster-info dump 将当前集群状态输出到 /path/to/cluster-state 1$ kubectl cluster-info dump --output-directory&#x3D;&#x2F;path&#x2F;to&#x2F;cluster-state 如果该键和影响的污点（taint）已存在，则使用指定的值替换 1$ kubectl taint nodes foo dedicated&#x3D;special-user:NoSchedule 资源类型 缩写别名 clusters componentstatuses cs configmaps cm daemonsets ds deployments deploy endpoints ep event ev horizontalpodautoscalers hpa ingresses ing jobs limitranges limits namespaces ns networkpolicies nodes no statefulsets persistentvolumeclaims pvc persistentvolumes pv pods po podsecuritypolicies psp podtemplates replicasets rs replicationcontrollers rc resourcequotas quota cronjob secrets serviceaccount sa services svc storageclasses kubectl get - 显示资源列表#获取类型为Deployment的资源列表 1kubectl get deployments #获取类型为Pod的资源列表 1kubectl get pods #获取类型为Node的资源列表 1kubectl get nodes 名称空间在命令后增加 -A 或 –all-namespaces 可查看所有名称空间中的对象，使用参数 -n 可查看指定名称空间的对象，例如 # 查看所有名称空间的 Deployment 12kubectl get deployments -A kubectl get deployments --all-namespaces 查看 kube-system 名称空间的 Deployment 1kubectl get deployments -n kube-system 检查 kubectl 是否知道集群地址及凭证 1$ kubectl config view 通过 kubectl cluster-info 命令获得这些服务列表： 12345[root@ebs ~]# kubectl cluster-info Kubernetes master is running at https:&#x2F;&#x2F;172.16.121.88:6443 KubeDNS is running at https:&#x2F;&#x2F;172.16.121.88:6443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;kube-system&#x2F;services&#x2F;kube-dns:dns&#x2F;proxy To further debug and diagnose cluster problems, use &#39;kubectl cluster-info dump&#39;.","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://yoursite.com/categories/kubernetes/"}],"tags":[]},{"title":"web","slug":"web/hexo使用","date":"2020-03-19T09:18:36.000Z","updated":"2020-03-20T06:36:47.948Z","comments":true,"path":"2020/03/19/web/hexo使用/","link":"","permalink":"http://yoursite.com/2020/03/19/web/hexo%E4%BD%BF%E7%94%A8/","excerpt":"","text":"_config.yml配置git 1234deploy: type: &#39;git&#39; repo: git@github.com:liudelongqwer&#x2F;mengmo.github.io.git branch: master 上传github，推送文件步骤： hexo clean hexo c 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo generate hexo g 生成静态文件 hexo deploy hexo d 部署网站 执行端口启动： hexo s -i 0.0.0.0 -p 8080 绑定个人域名： 解析域名重点：博客网址中必须使用你github的用户名 布局（Layout） Hexo 有三种默认布局：post、page 和 draft。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局 路径 post source/_posts page source draft source/_drafts hexo init 1hexo init [ folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 hexo new 1hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 hexo new “post title with whitespace” 参数 描述 -p, –path 自定义新文章的路径 -r, –replace 如果存在同名文章，将其替换 -s, –slug 文章的 Slug，作为新文章的文件名和发布后的 URL 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录： 1hexo new page --path about&#x2F;me &quot;About me&quot; 以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 “About me” 注意！title 是必须指定的！如果你这么做并不能达到你的目的： 1hexo new page --path about&#x2F;me 此时 Hexo 会创建 source/_posts/about/me.md，同时 me.md 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://yoursite.com/categories/kubernetes/"}],"tags":[]}]}